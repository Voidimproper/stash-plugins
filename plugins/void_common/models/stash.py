# generated by datamodel-codegen:
#   filename:  full-schema.graphql
#   timestamp: 2025-09-22T18:59:26+00:00

from __future__ import annotations

from enum import Enum
from typing import List, Literal, Optional, TypeAlias, Union

from pydantic import BaseModel, Field

Any: TypeAlias = str


BoolMap: TypeAlias = str
"""
A String -> Boolean map
"""


Boolean: TypeAlias = bool
"""
The `Boolean` scalar type represents `true` or `false`.
"""


Float: TypeAlias = float
"""
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
"""


ID: TypeAlias = str
"""
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
"""


Int: TypeAlias = int
"""
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
"""


Int64: TypeAlias = str


Map: TypeAlias = str
"""
A String -> Any map
"""


PluginConfigMap: TypeAlias = str
"""
A plugin ID -> Map (String -> Any map) map
"""


String: TypeAlias = str
"""
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
"""


Time: TypeAlias = str
"""
An RFC3339 timestamp
"""


Timestamp: TypeAlias = str
"""
Timestamp is a point in time. It is always output as RFC3339-compatible time points.
It can be input as a RFC3339 string, or as "<4h" for "4 hours in the past" or ">5m"
for "5 minutes in the future"
"""


Upload: TypeAlias = str
"""
A multipart file upload
"""


class BlobsStorageType(Enum):
    DATABASE = "DATABASE"
    FILESYSTEM = "FILESYSTEM"


class BulkUpdateIdMode(Enum):
    ADD = "ADD"
    REMOVE = "REMOVE"
    SET = "SET"


class CircumisedEnum(Enum):
    CUT = "CUT"
    UNCUT = "UNCUT"


class CriterionModifier(Enum):
    BETWEEN = "BETWEEN"
    EQUALS = "EQUALS"
    EXCLUDES = "EXCLUDES"
    GREATER_THAN = "GREATER_THAN"
    INCLUDES = "INCLUDES"
    INCLUDES_ALL = "INCLUDES_ALL"
    IS_NULL = "IS_NULL"
    LESS_THAN = "LESS_THAN"
    MATCHES_REGEX = "MATCHES_REGEX"
    NOT_BETWEEN = "NOT_BETWEEN"
    NOT_EQUALS = "NOT_EQUALS"
    NOT_MATCHES_REGEX = "NOT_MATCHES_REGEX"
    NOT_NULL = "NOT_NULL"


class FilterMode(Enum):
    GALLERIES = "GALLERIES"
    GROUPS = "GROUPS"
    IMAGES = "IMAGES"
    MOVIES = "MOVIES"
    PERFORMERS = "PERFORMERS"
    SCENES = "SCENES"
    SCENE_MARKERS = "SCENE_MARKERS"
    STUDIOS = "STUDIOS"
    TAGS = "TAGS"


class GenderEnum(Enum):
    FEMALE = "FEMALE"
    INTERSEX = "INTERSEX"
    MALE = "MALE"
    NON_BINARY = "NON_BINARY"
    TRANSGENDER_FEMALE = "TRANSGENDER_FEMALE"
    TRANSGENDER_MALE = "TRANSGENDER_MALE"


class HashAlgorithm(Enum):
    MD5 = "MD5"
    OSHASH = "OSHASH"


class IdentifyFieldStrategy(Enum):
    IGNORE = "IGNORE"
    MERGE = "MERGE"
    OVERWRITE = "OVERWRITE"


class ImageLightboxDisplayMode(Enum):
    FIT_X = "FIT_X"
    FIT_XY = "FIT_XY"
    ORIGINAL = "ORIGINAL"


class ImageLightboxScrollMode(Enum):
    PAN_Y = "PAN_Y"
    ZOOM = "ZOOM"


class ImportDuplicateEnum(Enum):
    FAIL = "FAIL"
    IGNORE = "IGNORE"
    OVERWRITE = "OVERWRITE"


class ImportMissingRefEnum(Enum):
    CREATE = "CREATE"
    FAIL = "FAIL"
    IGNORE = "IGNORE"


class JobStatus(Enum):
    CANCELLED = "CANCELLED"
    FAILED = "FAILED"
    FINISHED = "FINISHED"
    READY = "READY"
    RUNNING = "RUNNING"
    STOPPING = "STOPPING"


class JobStatusUpdateType(Enum):
    ADD = "ADD"
    REMOVE = "REMOVE"
    UPDATE = "UPDATE"


class LogLevel(Enum):
    Debug = "Debug"
    Error = "Error"
    Info = "Info"
    Progress = "Progress"
    Trace = "Trace"
    Warning = "Warning"


class OrientationEnum(Enum):
    LANDSCAPE = "LANDSCAPE"
    PORTRAIT = "PORTRAIT"
    SQUARE = "SQUARE"


class PackageType(Enum):
    Plugin = "Plugin"
    Scraper = "Scraper"


class PluginSettingTypeEnum(Enum):
    BOOLEAN = "BOOLEAN"
    NUMBER = "NUMBER"
    STRING = "STRING"


class PreviewPreset(Enum):
    fast = "fast"
    medium = "medium"
    slow = "slow"
    slower = "slower"
    ultrafast = "ultrafast"
    veryfast = "veryfast"
    veryslow = "veryslow"


class ResolutionEnum(Enum):
    EIGHT_K = "EIGHT_K"
    FIVE_K = "FIVE_K"
    FOUR_K = "FOUR_K"
    FULL_HD = "FULL_HD"
    HUGE = "HUGE"
    LOW = "LOW"
    QUAD_HD = "QUAD_HD"
    R360P = "R360P"
    SEVEN_K = "SEVEN_K"
    SIX_K = "SIX_K"
    STANDARD = "STANDARD"
    STANDARD_HD = "STANDARD_HD"
    VERY_LOW = "VERY_LOW"
    VR_HD = "VR_HD"
    WEB_HD = "WEB_HD"


class ScrapeContentType(Enum):
    """
    Type of the content a scraper generates
    """

    GALLERY = "GALLERY"
    GROUP = "GROUP"
    IMAGE = "IMAGE"
    MOVIE = "MOVIE"
    PERFORMER = "PERFORMER"
    SCENE = "SCENE"


class ScrapeType(Enum):
    FRAGMENT = "FRAGMENT"
    NAME = "NAME"
    URL = "URL"


class SortDirectionEnum(Enum):
    ASC = "ASC"
    DESC = "DESC"


class StreamingResolutionEnum(Enum):
    FOUR_K = "FOUR_K"
    FULL_HD = "FULL_HD"
    LOW = "LOW"
    ORIGINAL = "ORIGINAL"
    STANDARD = "STANDARD"
    STANDARD_HD = "STANDARD_HD"


class SystemStatusEnum(Enum):
    NEEDS_MIGRATION = "NEEDS_MIGRATION"
    OK = "OK"
    SETUP = "SETUP"


class BaseFile(BaseModel):
    basename: String
    created_at: Time
    fingerprint: Optional[String] = None
    fingerprints: List[Fingerprint]
    id: ID
    mod_time: Time
    parent_folder_id: ID
    path: String
    size: Int64
    updated_at: Time
    zip_file_id: Optional[ID] = None
    typename__: Optional[Literal["BaseFile"]] = Field("BaseFile", alias="__typename")


class AutoTagMetadataOptions(BaseModel):
    performers: Optional[List[String]] = Field(None, description='IDs of performers to tag files with, or "*" for all')
    studios: Optional[List[String]] = Field(None, description='IDs of studios to tag files with, or "*" for all')
    tags: Optional[List[String]] = Field(None, description='IDs of tags to tag files with, or "*" for all')
    typename__: Optional[Literal["AutoTagMetadataOptions"]] = Field("AutoTagMetadataOptions", alias="__typename")


class ConfigDLNAResult(BaseModel):
    enabled: Boolean = Field(..., description="True if DLNA service should be enabled by default")
    interfaces: List[String] = Field(..., description="List of interfaces to run DLNA on. Empty for all")
    port: Int = Field(..., description="Defaults to 1338")
    serverName: String
    videoSortOrder: String = Field(..., description="Order to sort videos")
    whitelistedIPs: List[String] = Field(..., description="List of IPs whitelisted for DLNA service")
    typename__: Optional[Literal["ConfigDLNAResult"]] = Field("ConfigDLNAResult", alias="__typename")


class ConfigDefaultSettingsResult(BaseModel):
    autoTag: Optional[AutoTagMetadataOptions] = None
    deleteFile: Optional[Boolean] = Field(None, description="If true, delete file checkbox will be checked by default")
    deleteGenerated: Optional[Boolean] = Field(
        None, description="If true, delete generated supporting files checkbox will be checked by default"
    )
    generate: Optional[GenerateMetadataOptions] = None
    identify: Optional[IdentifyMetadataTaskOptions] = None
    scan: Optional[ScanMetadataOptions] = None
    typename__: Optional[Literal["ConfigDefaultSettingsResult"]] = Field(
        "ConfigDefaultSettingsResult", alias="__typename"
    )


class ConfigDisableDropdownCreate(BaseModel):
    movie: Boolean
    performer: Boolean
    studio: Boolean
    tag: Boolean
    typename__: Optional[Literal["ConfigDisableDropdownCreate"]] = Field(
        "ConfigDisableDropdownCreate", alias="__typename"
    )


class ConfigGeneralResult(BaseModel):
    apiKey: String = Field(..., description="API Key")
    backupDirectoryPath: String = Field(..., description="Path to backup directory")
    blobsPath: String = Field(..., description="Path to blobs - required for filesystem blob storage")
    blobsStorage: BlobsStorageType = Field(..., description="Where to store blobs")
    cachePath: String = Field(..., description="Path to cache")
    calculateMD5: Boolean = Field(..., description="Whether to calculate MD5 checksums for scene video files")
    configFilePath: String = Field(..., description="Path to the config file used")
    createGalleriesFromFolders: Boolean = Field(
        ..., description="True if galleries should be created from folders with images"
    )
    createImageClipsFromVideos: Boolean = Field(
        ..., description="Create Image Clips from Video extensions when Videos are disabled in Library"
    )
    customPerformerImageLocation: Optional[String] = Field(None, description="Custom Performer Image Location")
    databasePath: String = Field(..., description="Path to the SQLite database")
    drawFunscriptHeatmapRange: Boolean = Field(
        ..., description="whether to include range in generated funscript heatmaps"
    )
    excludes: List[String] = Field(..., description="Array of file regexp to exclude from Video Scans")
    ffmpegPath: String = Field(
        ...,
        description="Path to the ffmpeg binary. If empty, stash will attempt to find it in the path or config directory",
    )
    ffprobePath: String = Field(
        ...,
        description="Path to the ffprobe binary. If empty, stash will attempt to find it in the path or config directory",
    )
    galleryCoverRegex: String = Field(..., description="Regex used to identify images as gallery covers")
    galleryExtensions: List[String] = Field(..., description="Array of gallery zip file extensions")
    generatedPath: String = Field(..., description="Path to generated files")
    imageExcludes: List[String] = Field(..., description="Array of file regexp to exclude from Image Scans")
    imageExtensions: List[String] = Field(..., description="Array of image file extensions")
    liveTranscodeInputArgs: List[String] = Field(
        ...,
        description="ffmpeg stream input args - injected before input file\nThese are applied when live transcoding",
    )
    liveTranscodeOutputArgs: List[String] = Field(
        ...,
        description="ffmpeg stream output args - injected before output file\nThese are applied when live transcoding",
    )
    logAccess: Boolean = Field(..., description="Whether to log http access")
    logFile: Optional[String] = Field(None, description="Name of the log file")
    logLevel: String = Field(..., description="Minimum log level")
    logOut: Boolean = Field(..., description="Whether to also output to stderr")
    maxSessionAge: Int = Field(..., description="Maximum session cookie age")
    maxStreamingTranscodeSize: Optional[StreamingResolutionEnum] = Field(
        None, description="Max streaming transcode size"
    )
    maxTranscodeSize: Optional[StreamingResolutionEnum] = Field(None, description="Max generated transcode size")
    metadataPath: String = Field(..., description="Path to import/export files")
    parallelTasks: Int = Field(..., description="Number of parallel tasks to start during scan/generate")
    password: String = Field(..., description="Password")
    pluginPackageSources: List[PackageSource] = Field(..., description="Source of plugin packages")
    pluginsPath: String = Field(..., description="Path to plugins")
    previewAudio: Boolean = Field(..., description="Include audio stream in previews")
    previewExcludeEnd: String = Field(..., description="Duration of end of video to exclude when generating previews")
    previewExcludeStart: String = Field(
        ..., description="Duration of start of video to exclude when generating previews"
    )
    previewPreset: PreviewPreset = Field(..., description="Preset when generating preview")
    previewSegmentDuration: Float = Field(..., description="Preview segment duration, in seconds")
    previewSegments: Int = Field(..., description="Number of segments in a preview file")
    pythonPath: String = Field(..., description="Python path - resolved using path if unset")
    scraperPackageSources: List[PackageSource] = Field(..., description="Source of scraper packages")
    scrapersPath: String = Field(..., description="Path to scrapers")
    stashBoxes: List[StashBox] = Field(..., description="Stash-box instances used for tagging")
    stashes: List[StashConfig] = Field(..., description="Array of file paths to content")
    transcodeHardwareAcceleration: Boolean = Field(..., description="Transcode Hardware Acceleration")
    transcodeInputArgs: List[String] = Field(
        ...,
        description="ffmpeg transcode input args - injected before input file\nThese are applied to generated transcodes (previews and transcodes)",
    )
    transcodeOutputArgs: List[String] = Field(
        ...,
        description="ffmpeg transcode output args - injected before output file\nThese are applied to generated transcodes (previews and transcodes)",
    )
    username: String = Field(..., description="Username")
    videoExtensions: List[String] = Field(..., description="Array of video file extensions")
    videoFileNamingAlgorithm: HashAlgorithm = Field(..., description="Hash algorithm to use for generated file naming")
    writeImageThumbnails: Boolean = Field(..., description="Write image thumbnails to disk when generating on the fly")
    typename__: Optional[Literal["ConfigGeneralResult"]] = Field("ConfigGeneralResult", alias="__typename")


class ConfigImageLightboxResult(BaseModel):
    displayMode: Optional[ImageLightboxDisplayMode] = None
    resetZoomOnNav: Optional[Boolean] = None
    scaleUp: Optional[Boolean] = None
    scrollAttemptsBeforeChange: Int
    scrollMode: Optional[ImageLightboxScrollMode] = None
    slideshowDelay: Optional[Int] = None
    typename__: Optional[Literal["ConfigImageLightboxResult"]] = Field("ConfigImageLightboxResult", alias="__typename")


class ConfigInterfaceResult(BaseModel):
    autostartVideo: Optional[Boolean] = Field(
        None, description="If true, video will autostart on load in the scene player"
    )
    autostartVideoOnPlaySelected: Optional[Boolean] = Field(
        None, description="If true, video will autostart when loading from play random or play selected"
    )
    continuePlaylistDefault: Optional[Boolean] = Field(
        None, description="If true, next scene in playlist will be played at video end by default"
    )
    css: Optional[String] = Field(None, description="Custom CSS")
    cssEnabled: Optional[Boolean] = None
    customLocales: Optional[String] = Field(None, description="Custom Locales")
    customLocalesEnabled: Optional[Boolean] = None
    disableDropdownCreate: ConfigDisableDropdownCreate = Field(
        ..., description="Fields are true if creating via dropdown menus are disabled"
    )
    funscriptOffset: Optional[Int] = Field(None, description="Funscript Time Offset")
    handyKey: Optional[String] = Field(None, description="Handy Connection Key")
    imageLightbox: ConfigImageLightboxResult
    javascript: Optional[String] = Field(None, description="Custom Javascript")
    javascriptEnabled: Optional[Boolean] = None
    language: Optional[String] = Field(None, description="Interface language")
    maximumLoopDuration: Optional[Int] = Field(
        None, description="Maximum duration (in seconds) in which a scene video will loop in the scene player"
    )
    menuItems: Optional[List[String]] = Field(
        None, description="Ordered list of items that should be shown in the menu"
    )
    noBrowser: Optional[Boolean] = Field(
        None, description="True if we should not auto-open a browser window on startup"
    )
    notificationsEnabled: Optional[Boolean] = Field(None, description="True if we should send desktop notifications")
    showScrubber: Optional[Boolean] = Field(None, description="Show scene scrubber by default")
    showStudioAsText: Optional[Boolean] = Field(
        None, description="If true, studio overlays will be shown as text instead of logo images"
    )
    soundOnPreview: Optional[Boolean] = Field(None, description="Enable sound on mouseover previews")
    useStashHostedFunscript: Optional[Boolean] = Field(None, description="Whether to use Stash Hosted Funscript")
    wallPlayback: Optional[String] = Field(None, description="Wall playback type")
    wallShowTitle: Optional[Boolean] = Field(None, description="Show title and tags in wall view")
    typename__: Optional[Literal["ConfigInterfaceResult"]] = Field("ConfigInterfaceResult", alias="__typename")


class ConfigResult(BaseModel):
    """
    All configuration settings
    """

    defaults: ConfigDefaultSettingsResult
    dlna: ConfigDLNAResult
    general: ConfigGeneralResult
    interface: ConfigInterfaceResult
    plugins: PluginConfigMap
    scraping: ConfigScrapingResult
    ui: Map
    typename__: Optional[Literal["ConfigResult"]] = Field("ConfigResult", alias="__typename")


class ConfigScrapingResult(BaseModel):
    excludeTagPatterns: List[String] = Field(..., description="Tags blacklist during scraping")
    scraperCDPPath: Optional[String] = Field(
        None, description="Scraper CDP path. Path to chrome executable or remote address"
    )
    scraperCertCheck: Boolean = Field(..., description="Whether the scraper should check for invalid certificates")
    scraperUserAgent: Optional[String] = Field(None, description="Scraper user agent string")
    typename__: Optional[Literal["ConfigScrapingResult"]] = Field("ConfigScrapingResult", alias="__typename")


class DLNAIP(BaseModel):
    ipAddress: String
    until: Optional[Time] = Field(None, description="Time until IP will be no longer allowed/disallowed")
    typename__: Optional[Literal["DLNAIP"]] = Field("DLNAIP", alias="__typename")


class DLNAStatus(BaseModel):
    allowedIPAddresses: List[DLNAIP]
    recentIPAddresses: List[String]
    running: Boolean
    until: Optional[Time] = Field(
        None,
        description="If not currently running, time until it will be started. If running, time until it will be stopped",
    )
    typename__: Optional[Literal["DLNAStatus"]] = Field("DLNAStatus", alias="__typename")


class Directory(BaseModel):
    """
    Directory structure of a path
    """

    directories: List[String]
    parent: Optional[String] = None
    path: String
    typename__: Optional[Literal["Directory"]] = Field("Directory", alias="__typename")


class FindGalleriesResultType(BaseModel):
    count: Int
    galleries: List[Gallery]
    typename__: Optional[Literal["FindGalleriesResultType"]] = Field("FindGalleriesResultType", alias="__typename")


class FindGalleryChaptersResultType(BaseModel):
    chapters: List[GalleryChapter]
    count: Int
    typename__: Optional[Literal["FindGalleryChaptersResultType"]] = Field(
        "FindGalleryChaptersResultType", alias="__typename"
    )


class FindGroupsResultType(BaseModel):
    count: Int
    groups: List[Group]
    typename__: Optional[Literal["FindGroupsResultType"]] = Field("FindGroupsResultType", alias="__typename")


class FindImagesResultType(BaseModel):
    count: Int
    filesize: Float = Field(..., description="Total file size in bytes")
    images: List[Image]
    megapixels: Float = Field(..., description="Total megapixels of the images")
    typename__: Optional[Literal["FindImagesResultType"]] = Field("FindImagesResultType", alias="__typename")


class FindMoviesResultType(BaseModel):
    count: Int
    movies: List[Movie]
    typename__: Optional[Literal["FindMoviesResultType"]] = Field("FindMoviesResultType", alias="__typename")


class FindPerformersResultType(BaseModel):
    count: Int
    performers: List[Performer]
    typename__: Optional[Literal["FindPerformersResultType"]] = Field("FindPerformersResultType", alias="__typename")


class FindSceneMarkersResultType(BaseModel):
    count: Int
    scene_markers: List[SceneMarker]
    typename__: Optional[Literal["FindSceneMarkersResultType"]] = Field(
        "FindSceneMarkersResultType", alias="__typename"
    )


class FindScenesResultType(BaseModel):
    count: Int
    duration: Float = Field(..., description="Total duration in seconds")
    filesize: Float = Field(..., description="Total file size in bytes")
    scenes: List[Scene]
    typename__: Optional[Literal["FindScenesResultType"]] = Field("FindScenesResultType", alias="__typename")


class FindStudiosResultType(BaseModel):
    count: Int
    studios: List[Studio]
    typename__: Optional[Literal["FindStudiosResultType"]] = Field("FindStudiosResultType", alias="__typename")


class FindTagsResultType(BaseModel):
    count: Int
    tags: List[Tag]
    typename__: Optional[Literal["FindTagsResultType"]] = Field("FindTagsResultType", alias="__typename")


class Fingerprint(BaseModel):
    type: String
    value: String
    typename__: Optional[Literal["Fingerprint"]] = Field("Fingerprint", alias="__typename")


class Folder(BaseModel):
    created_at: Time
    id: ID
    mod_time: Time
    parent_folder_id: Optional[ID] = None
    path: String
    updated_at: Time
    zip_file_id: Optional[ID] = None
    typename__: Optional[Literal["Folder"]] = Field("Folder", alias="__typename")


class Gallery(BaseModel):
    """
    Gallery type
    """

    chapters: List[GalleryChapter]
    code: Optional[String] = None
    cover: Optional[Image] = None
    created_at: Time
    date: Optional[String] = None
    details: Optional[String] = None
    files: List[GalleryFile]
    folder: Optional[Folder] = None
    id: ID
    image: Image
    image_count: Int
    organized: Boolean
    paths: GalleryPathsType
    performers: List[Performer]
    photographer: Optional[String] = None
    rating100: Optional[Int] = None
    scenes: List[Scene]
    studio: Optional[Studio] = None
    tags: List[Tag]
    title: Optional[String] = None
    updated_at: Time
    url: Optional[String] = None
    urls: List[String]
    typename__: Optional[Literal["Gallery"]] = Field("Gallery", alias="__typename")


class GalleryChapter(BaseModel):
    created_at: Time
    gallery: Gallery
    id: ID
    image_index: Int
    title: String
    updated_at: Time
    typename__: Optional[Literal["GalleryChapter"]] = Field("GalleryChapter", alias="__typename")


class GalleryFile(BaseFile):
    basename: String
    created_at: Time
    fingerprint: Optional[String] = None
    fingerprints: List[Fingerprint]
    id: ID
    mod_time: Time
    parent_folder_id: ID
    path: String
    size: Int64
    updated_at: Time
    zip_file_id: Optional[ID] = None
    typename__: Optional[Literal["GalleryFile"]] = Field("GalleryFile", alias="__typename")  # type: ignore[assignment]


class GalleryPathsType(BaseModel):
    cover: String
    preview: String
    typename__: Optional[Literal["GalleryPathsType"]] = Field("GalleryPathsType", alias="__typename")


class GenerateMetadataOptions(BaseModel):
    clipPreviews: Optional[Boolean] = None
    covers: Optional[Boolean] = None
    imagePreviews: Optional[Boolean] = None
    imageThumbnails: Optional[Boolean] = None
    interactiveHeatmapsSpeeds: Optional[Boolean] = None
    markerImagePreviews: Optional[Boolean] = None
    markerScreenshots: Optional[Boolean] = None
    markers: Optional[Boolean] = None
    phashes: Optional[Boolean] = None
    previewOptions: Optional[GeneratePreviewOptions] = None
    previews: Optional[Boolean] = None
    sprites: Optional[Boolean] = None
    transcodes: Optional[Boolean] = None
    typename__: Optional[Literal["GenerateMetadataOptions"]] = Field("GenerateMetadataOptions", alias="__typename")


class GeneratePreviewOptions(BaseModel):
    previewExcludeEnd: Optional[String] = Field(
        None, description="Duration of end of video to exclude when generating previews"
    )
    previewExcludeStart: Optional[String] = Field(
        None, description="Duration of start of video to exclude when generating previews"
    )
    previewPreset: Optional[PreviewPreset] = Field(None, description="Preset when generating preview")
    previewSegmentDuration: Optional[Float] = Field(None, description="Preview segment duration, in seconds")
    previewSegments: Optional[Int] = Field(None, description="Number of segments in a preview file")
    typename__: Optional[Literal["GeneratePreviewOptions"]] = Field("GeneratePreviewOptions", alias="__typename")


class Group(BaseModel):
    aliases: Optional[String] = None
    back_image_path: Optional[String] = None
    containing_groups: List[GroupDescription]
    created_at: Time
    date: Optional[String] = None
    director: Optional[String] = None
    duration: Optional[Int] = Field(None, description="Duration in seconds")
    front_image_path: Optional[String] = None
    id: ID
    name: String
    rating100: Optional[Int] = None
    scene_count: Int
    scenes: List[Scene]
    studio: Optional[Studio] = None
    sub_group_count: Int
    sub_groups: List[GroupDescription]
    synopsis: Optional[String] = None
    tags: List[Tag]
    updated_at: Time
    urls: List[String]
    typename__: Optional[Literal["Group"]] = Field("Group", alias="__typename")


class GroupDescription(BaseModel):
    """
    GroupDescription represents a relationship to a group with a description of the relationship
    """

    description: Optional[String] = None
    group: Group
    typename__: Optional[Literal["GroupDescription"]] = Field("GroupDescription", alias="__typename")


class HistoryMutationResult(BaseModel):
    count: Int
    history: List[Time]
    typename__: Optional[Literal["HistoryMutationResult"]] = Field("HistoryMutationResult", alias="__typename")


class IdentifyFieldOptions(BaseModel):
    createMissing: Optional[Boolean] = Field(
        None, description="creates missing objects if needed - only applicable for performers, tags and studios"
    )
    field: String
    strategy: IdentifyFieldStrategy
    typename__: Optional[Literal["IdentifyFieldOptions"]] = Field("IdentifyFieldOptions", alias="__typename")


class IdentifyMetadataOptions(BaseModel):
    fieldOptions: Optional[List[IdentifyFieldOptions]] = Field(
        None, description="any fields missing from here are defaulted to MERGE and createMissing false"
    )
    includeMalePerformers: Optional[Boolean] = Field(None, description="defaults to true if not provided")
    setCoverImage: Optional[Boolean] = Field(None, description="defaults to true if not provided")
    setOrganized: Optional[Boolean] = None
    skipMultipleMatchTag: Optional[String] = Field(None, description="tag to tag skipped multiple matches with")
    skipMultipleMatches: Optional[Boolean] = Field(None, description="defaults to true if not provided")
    skipSingleNamePerformerTag: Optional[String] = Field(
        None, description="tag to tag skipped single name performers with"
    )
    skipSingleNamePerformers: Optional[Boolean] = Field(None, description="defaults to true if not provided")
    typename__: Optional[Literal["IdentifyMetadataOptions"]] = Field("IdentifyMetadataOptions", alias="__typename")


class IdentifyMetadataTaskOptions(BaseModel):
    options: Optional[IdentifyMetadataOptions] = Field(
        None, description="Options defined here override the configured defaults"
    )
    sources: List[IdentifySource] = Field(
        ...,
        description="An ordered list of sources to identify items with. Only the first source that finds a match is used.",
    )
    typename__: Optional[Literal["IdentifyMetadataTaskOptions"]] = Field(
        "IdentifyMetadataTaskOptions", alias="__typename"
    )


class IdentifySource(BaseModel):
    options: Optional[IdentifyMetadataOptions] = Field(
        None, description="Options defined for a source override the defaults"
    )
    source: ScraperSource
    typename__: Optional[Literal["IdentifySource"]] = Field("IdentifySource", alias="__typename")


class Image(BaseModel):
    code: Optional[String] = None
    created_at: Time
    date: Optional[String] = None
    details: Optional[String] = None
    files: List[ImageFile]
    galleries: List[Gallery]
    id: ID
    o_counter: Optional[Int] = None
    organized: Boolean
    paths: ImagePathsType
    performers: List[Performer]
    photographer: Optional[String] = None
    rating100: Optional[Int] = None
    studio: Optional[Studio] = None
    tags: List[Tag]
    title: Optional[String] = None
    updated_at: Time
    url: Optional[String] = None
    urls: List[String]
    visual_files: List[VisualFile]
    typename__: Optional[Literal["Image"]] = Field("Image", alias="__typename")


class ImageFile(BaseFile):
    basename: String
    created_at: Time
    fingerprint: Optional[String] = None
    fingerprints: List[Fingerprint]
    height: Int
    id: ID
    mod_time: Time
    parent_folder_id: ID
    path: String
    size: Int64
    updated_at: Time
    width: Int
    zip_file_id: Optional[ID] = None
    typename__: Optional[Literal["ImageFile"]] = Field("ImageFile", alias="__typename")  # type: ignore[assignment]


class ImageFileType(BaseModel):
    height: Int
    mod_time: Time
    size: Int
    width: Int
    typename__: Optional[Literal["ImageFileType"]] = Field("ImageFileType", alias="__typename")


class ImagePathsType(BaseModel):
    image: Optional[String] = None
    preview: Optional[String] = None
    thumbnail: Optional[String] = None
    typename__: Optional[Literal["ImagePathsType"]] = Field("ImagePathsType", alias="__typename")


class Job(BaseModel):
    addTime: Time
    description: String
    endTime: Optional[Time] = None
    error: Optional[String] = None
    id: ID
    progress: Optional[Float] = None
    startTime: Optional[Time] = None
    status: JobStatus
    subTasks: Optional[List[String]] = None
    typename__: Optional[Literal["Job"]] = Field("Job", alias="__typename")


class JobStatusUpdate(BaseModel):
    job: Job
    type: JobStatusUpdateType
    typename__: Optional[Literal["JobStatusUpdate"]] = Field("JobStatusUpdate", alias="__typename")


class LatestVersion(BaseModel):
    release_date: String
    shorthash: String
    url: String
    version: String
    typename__: Optional[Literal["LatestVersion"]] = Field("LatestVersion", alias="__typename")


class LogEntry(BaseModel):
    level: LogLevel
    message: String
    time: Time
    typename__: Optional[Literal["LogEntry"]] = Field("LogEntry", alias="__typename")


class MarkerStringsResultType(BaseModel):
    count: Int
    id: ID
    title: String
    typename__: Optional[Literal["MarkerStringsResultType"]] = Field("MarkerStringsResultType", alias="__typename")


class Movie(BaseModel):
    aliases: Optional[String] = None
    back_image_path: Optional[String] = None
    created_at: Time
    date: Optional[String] = None
    director: Optional[String] = None
    duration: Optional[Int] = Field(None, description="Duration in seconds")
    front_image_path: Optional[String] = None
    id: ID
    name: String
    rating100: Optional[Int] = None
    scene_count: Int
    scenes: List[Scene]
    studio: Optional[Studio] = None
    synopsis: Optional[String] = None
    tags: List[Tag]
    updated_at: Time
    url: Optional[String] = None
    urls: List[String]
    typename__: Optional[Literal["Movie"]] = Field("Movie", alias="__typename")


class Package(BaseModel):
    date: Optional[Timestamp] = None
    metadata: Map
    name: String
    package_id: String
    requires: List[Package]
    sourceURL: String
    source_package: Optional[Package] = Field(
        None, description="The version of this package currently available from the remote source"
    )
    version: Optional[String] = None
    typename__: Optional[Literal["Package"]] = Field("Package", alias="__typename")


class PackageSource(BaseModel):
    local_path: Optional[String] = None
    name: Optional[String] = None
    url: String
    typename__: Optional[Literal["PackageSource"]] = Field("PackageSource", alias="__typename")


class Performer(BaseModel):
    alias_list: List[String]
    birthdate: Optional[String] = None
    career_length: Optional[String] = None
    circumcised: Optional[CircumisedEnum] = None
    country: Optional[String] = None
    created_at: Time
    custom_fields: Map
    death_date: Optional[String] = None
    details: Optional[String] = None
    disambiguation: Optional[String] = None
    ethnicity: Optional[String] = None
    eye_color: Optional[String] = None
    fake_tits: Optional[String] = None
    favorite: Boolean
    gallery_count: Int
    gender: Optional[GenderEnum] = None
    group_count: Int
    groups: List[Group]
    hair_color: Optional[String] = None
    height_cm: Optional[Int] = None
    id: ID
    ignore_auto_tag: Boolean
    image_count: Int
    image_path: Optional[String] = None
    instagram: Optional[String] = None
    measurements: Optional[String] = None
    movie_count: Int
    movies: List[Movie]
    name: String
    o_counter: Optional[Int] = None
    penis_length: Optional[Float] = None
    performer_count: Int
    piercings: Optional[String] = None
    rating100: Optional[Int] = None
    scene_count: Int
    scenes: List[Scene]
    stash_ids: List[StashID]
    tags: List[Tag]
    tattoos: Optional[String] = None
    twitter: Optional[String] = None
    updated_at: Time
    url: Optional[String] = None
    urls: Optional[List[String]] = None
    weight: Optional[Int] = None
    typename__: Optional[Literal["Performer"]] = Field("Performer", alias="__typename")


class Plugin(BaseModel):
    description: Optional[String] = None
    enabled: Boolean
    hooks: Optional[List[PluginHook]] = None
    id: ID
    name: String
    paths: PluginPaths
    requires: Optional[List[ID]] = Field(
        None,
        description="Plugin IDs of plugins that this plugin depends on.\nApplies only for UI plugins to indicate css/javascript load order.",
    )
    settings: Optional[List[PluginSetting]] = None
    tasks: Optional[List[PluginTask]] = None
    url: Optional[String] = None
    version: Optional[String] = None
    typename__: Optional[Literal["Plugin"]] = Field("Plugin", alias="__typename")


class PluginHook(BaseModel):
    description: Optional[String] = None
    hooks: Optional[List[String]] = None
    name: String
    plugin: Plugin
    typename__: Optional[Literal["PluginHook"]] = Field("PluginHook", alias="__typename")


class PluginPaths(BaseModel):
    css: Optional[List[String]] = None
    javascript: Optional[List[String]] = None
    typename__: Optional[Literal["PluginPaths"]] = Field("PluginPaths", alias="__typename")


class PluginResult(BaseModel):
    error: Optional[String] = None
    result: Optional[String] = None
    typename__: Optional[Literal["PluginResult"]] = Field("PluginResult", alias="__typename")


class PluginSetting(BaseModel):
    description: Optional[String] = None
    display_name: Optional[String] = None
    name: String
    type: PluginSettingTypeEnum
    typename__: Optional[Literal["PluginSetting"]] = Field("PluginSetting", alias="__typename")


class PluginTask(BaseModel):
    description: Optional[String] = None
    name: String
    plugin: Plugin
    typename__: Optional[Literal["PluginTask"]] = Field("PluginTask", alias="__typename")


class SQLExecResult(BaseModel):
    last_insert_id: Optional[Int64] = Field(
        None,
        description='The integer generated by the database in response to a command.\nTypically this will be from an "auto increment" column when inserting a new row.\nNot all databases support this feature, and the syntax of such statements varies.',
    )
    rows_affected: Optional[Int64] = Field(
        None,
        description="The number of rows affected by the query, usually an UPDATE, INSERT, or DELETE.\nNot all queries or databases support this feature.",
    )
    typename__: Optional[Literal["SQLExecResult"]] = Field("SQLExecResult", alias="__typename")


class SQLQueryResult(BaseModel):
    columns: List[String] = Field(..., description="The column names, in the order they appear in the result set.")
    rows: List[List[Any]] = Field(..., description="The returned rows.")
    typename__: Optional[Literal["SQLQueryResult"]] = Field("SQLQueryResult", alias="__typename")


class SavedFilter(BaseModel):
    filter: String = Field(..., description="JSON-encoded filter string")
    find_filter: Optional[SavedFindFilterType] = None
    id: ID
    mode: FilterMode
    name: String
    object_filter: Optional[Map] = None
    ui_options: Optional[Map] = None
    typename__: Optional[Literal["SavedFilter"]] = Field("SavedFilter", alias="__typename")


class SavedFindFilterType(BaseModel):
    direction: Optional[SortDirectionEnum] = None
    page: Optional[Int] = None
    per_page: Optional[Int] = Field(None, description="use per_page = -1 to indicate all results. Defaults to 25.")
    q: Optional[String] = None
    sort: Optional[String] = None
    typename__: Optional[Literal["SavedFindFilterType"]] = Field("SavedFindFilterType", alias="__typename")


class ScanMetadataOptions(BaseModel):
    rescan: Boolean = Field(..., description="Forces a rescan on files even if modification time is unchanged")
    scanGenerateClipPreviews: Boolean = Field(..., description="Generate image clip previews during scan")
    scanGenerateCovers: Boolean = Field(..., description="Generate covers during scan")
    scanGenerateImagePreviews: Boolean = Field(..., description="Generate image previews during scan")
    scanGeneratePhashes: Boolean = Field(..., description="Generate phashes during scan")
    scanGeneratePreviews: Boolean = Field(..., description="Generate previews during scan")
    scanGenerateSprites: Boolean = Field(..., description="Generate sprites during scan")
    scanGenerateThumbnails: Boolean = Field(..., description="Generate image thumbnails during scan")
    typename__: Optional[Literal["ScanMetadataOptions"]] = Field("ScanMetadataOptions", alias="__typename")


class Scene(BaseModel):
    captions: Optional[List[VideoCaption]] = None
    code: Optional[String] = None
    created_at: Time
    date: Optional[String] = None
    details: Optional[String] = None
    director: Optional[String] = None
    files: List[VideoFile]
    galleries: List[Gallery]
    groups: List[SceneGroup]
    id: ID
    interactive: Boolean
    interactive_speed: Optional[Int] = None
    last_played_at: Optional[Time] = Field(None, description="The last time play count was updated")
    movies: List[SceneMovie]
    o_counter: Optional[Int] = None
    o_history: List[Time] = Field(..., description="Times the o counter was incremented")
    organized: Boolean
    paths: ScenePathsType
    performers: List[Performer]
    play_count: Optional[Int] = Field(None, description="The number ot times a scene has been played")
    play_duration: Optional[Float] = Field(None, description="The total time a scene has spent playing")
    play_history: List[Time] = Field(..., description="Times a scene was played")
    rating100: Optional[Int] = None
    resume_time: Optional[Float] = Field(None, description="The time index a scene was left at")
    sceneStreams: List[SceneStreamEndpoint] = Field(..., description="Return valid stream paths")
    scene_markers: List[SceneMarker]
    stash_ids: List[StashID]
    studio: Optional[Studio] = None
    tags: List[Tag]
    title: Optional[String] = None
    updated_at: Time
    url: Optional[String] = None
    urls: List[String]
    typename__: Optional[Literal["Scene"]] = Field("Scene", alias="__typename")


class SceneFileType(BaseModel):
    audio_codec: Optional[String] = None
    bitrate: Optional[Int] = None
    duration: Optional[Float] = None
    framerate: Optional[Float] = None
    height: Optional[Int] = None
    size: Optional[String] = None
    video_codec: Optional[String] = None
    width: Optional[Int] = None
    typename__: Optional[Literal["SceneFileType"]] = Field("SceneFileType", alias="__typename")


class SceneGroup(BaseModel):
    group: Group
    scene_index: Optional[Int] = None
    typename__: Optional[Literal["SceneGroup"]] = Field("SceneGroup", alias="__typename")


class SceneMarker(BaseModel):
    created_at: Time
    end_seconds: Optional[Float] = Field(
        None, description="The optional end time of the marker (in seconds). Supports decimals."
    )
    id: ID
    preview: String = Field(..., description="The path to the preview image for this marker")
    primary_tag: Tag
    scene: Scene
    screenshot: String = Field(..., description="The path to the screenshot image for this marker")
    seconds: Float = Field(..., description="The required start time of the marker (in seconds). Supports decimals.")
    stream: String = Field(..., description="The path to stream this marker")
    tags: List[Tag]
    title: String
    updated_at: Time
    typename__: Optional[Literal["SceneMarker"]] = Field("SceneMarker", alias="__typename")


class SceneMarkerTag(BaseModel):
    scene_markers: List[SceneMarker]
    tag: Tag
    typename__: Optional[Literal["SceneMarkerTag"]] = Field("SceneMarkerTag", alias="__typename")


class SceneMovie(BaseModel):
    movie: Movie
    scene_index: Optional[Int] = None
    typename__: Optional[Literal["SceneMovie"]] = Field("SceneMovie", alias="__typename")


class SceneMovieID(BaseModel):
    movie_id: ID
    scene_index: Optional[String] = None
    typename__: Optional[Literal["SceneMovieID"]] = Field("SceneMovieID", alias="__typename")


class SceneParserResult(BaseModel):
    code: Optional[String] = None
    date: Optional[String] = None
    details: Optional[String] = None
    director: Optional[String] = None
    gallery_ids: Optional[List[ID]] = None
    movies: Optional[List[SceneMovieID]] = None
    performer_ids: Optional[List[ID]] = None
    rating: Optional[Int] = None
    rating100: Optional[Int] = None
    scene: Scene
    studio_id: Optional[ID] = None
    tag_ids: Optional[List[ID]] = None
    title: Optional[String] = None
    url: Optional[String] = None
    typename__: Optional[Literal["SceneParserResult"]] = Field("SceneParserResult", alias="__typename")


class SceneParserResultType(BaseModel):
    count: Int
    results: List[SceneParserResult]
    typename__: Optional[Literal["SceneParserResultType"]] = Field("SceneParserResultType", alias="__typename")


class ScenePathsType(BaseModel):
    caption: Optional[String] = None
    funscript: Optional[String] = None
    interactive_heatmap: Optional[String] = None
    preview: Optional[String] = None
    screenshot: Optional[String] = None
    sprite: Optional[String] = None
    stream: Optional[String] = None
    vtt: Optional[String] = None
    webp: Optional[String] = None
    typename__: Optional[Literal["ScenePathsType"]] = Field("ScenePathsType", alias="__typename")


class SceneStreamEndpoint(BaseModel):
    label: Optional[String] = None
    mime_type: Optional[String] = None
    url: String
    typename__: Optional[Literal["SceneStreamEndpoint"]] = Field("SceneStreamEndpoint", alias="__typename")


class ScrapedGallery(BaseModel):
    code: Optional[String] = None
    date: Optional[String] = None
    details: Optional[String] = None
    performers: Optional[List[ScrapedPerformer]] = None
    photographer: Optional[String] = None
    studio: Optional[ScrapedStudio] = None
    tags: Optional[List[ScrapedTag]] = None
    title: Optional[String] = None
    url: Optional[String] = None
    urls: Optional[List[String]] = None
    typename__: Optional[Literal["ScrapedGallery"]] = Field("ScrapedGallery", alias="__typename")


class ScrapedGroup(BaseModel):
    """
    A group from a scraping operation...
    """

    aliases: Optional[String] = None
    back_image: Optional[String] = Field(None, description="This should be a base64 encoded data URL")
    date: Optional[String] = None
    director: Optional[String] = None
    duration: Optional[String] = None
    front_image: Optional[String] = Field(None, description="This should be a base64 encoded data URL")
    name: Optional[String] = None
    rating: Optional[String] = None
    stored_id: Optional[ID] = None
    studio: Optional[ScrapedStudio] = None
    synopsis: Optional[String] = None
    tags: Optional[List[ScrapedTag]] = None
    urls: Optional[List[String]] = None
    typename__: Optional[Literal["ScrapedGroup"]] = Field("ScrapedGroup", alias="__typename")


class ScrapedImage(BaseModel):
    code: Optional[String] = None
    date: Optional[String] = None
    details: Optional[String] = None
    performers: Optional[List[ScrapedPerformer]] = None
    photographer: Optional[String] = None
    studio: Optional[ScrapedStudio] = None
    tags: Optional[List[ScrapedTag]] = None
    title: Optional[String] = None
    urls: Optional[List[String]] = None
    typename__: Optional[Literal["ScrapedImage"]] = Field("ScrapedImage", alias="__typename")


class ScrapedMovie(BaseModel):
    """
    A movie from a scraping operation...
    """

    aliases: Optional[String] = None
    back_image: Optional[String] = Field(None, description="This should be a base64 encoded data URL")
    date: Optional[String] = None
    director: Optional[String] = None
    duration: Optional[String] = None
    front_image: Optional[String] = Field(None, description="This should be a base64 encoded data URL")
    name: Optional[String] = None
    rating: Optional[String] = None
    stored_id: Optional[ID] = None
    studio: Optional[ScrapedStudio] = None
    synopsis: Optional[String] = None
    tags: Optional[List[ScrapedTag]] = None
    url: Optional[String] = None
    urls: Optional[List[String]] = None
    typename__: Optional[Literal["ScrapedMovie"]] = Field("ScrapedMovie", alias="__typename")


class ScrapedPerformer(BaseModel):
    """
    A performer from a scraping operation...
    """

    aliases: Optional[String] = None
    birthdate: Optional[String] = None
    career_length: Optional[String] = None
    circumcised: Optional[String] = None
    country: Optional[String] = None
    death_date: Optional[String] = None
    details: Optional[String] = None
    disambiguation: Optional[String] = None
    ethnicity: Optional[String] = None
    eye_color: Optional[String] = None
    fake_tits: Optional[String] = None
    gender: Optional[String] = None
    hair_color: Optional[String] = None
    height: Optional[String] = None
    image: Optional[String] = Field(None, description="This should be a base64 encoded data URL")
    images: Optional[List[String]] = None
    instagram: Optional[String] = None
    measurements: Optional[String] = None
    name: Optional[String] = None
    penis_length: Optional[String] = None
    piercings: Optional[String] = None
    remote_site_id: Optional[String] = None
    stored_id: Optional[ID] = Field(None, description="Set if performer matched")
    tags: Optional[List[ScrapedTag]] = None
    tattoos: Optional[String] = None
    twitter: Optional[String] = None
    url: Optional[String] = None
    urls: Optional[List[String]] = None
    weight: Optional[String] = None
    typename__: Optional[Literal["ScrapedPerformer"]] = Field("ScrapedPerformer", alias="__typename")


class ScrapedScene(BaseModel):
    code: Optional[String] = None
    date: Optional[String] = None
    details: Optional[String] = None
    director: Optional[String] = None
    duration: Optional[Int] = None
    file: Optional[SceneFileType] = None
    fingerprints: Optional[List[StashBoxFingerprint]] = None
    groups: Optional[List[ScrapedGroup]] = None
    image: Optional[String] = Field(None, description="This should be a base64 encoded data URL")
    movies: Optional[List[ScrapedMovie]] = None
    performers: Optional[List[ScrapedPerformer]] = None
    remote_site_id: Optional[String] = None
    studio: Optional[ScrapedStudio] = None
    tags: Optional[List[ScrapedTag]] = None
    title: Optional[String] = None
    url: Optional[String] = None
    urls: Optional[List[String]] = None
    typename__: Optional[Literal["ScrapedScene"]] = Field("ScrapedScene", alias="__typename")


class ScrapedStudio(BaseModel):
    image: Optional[String] = None
    name: String
    parent: Optional[ScrapedStudio] = None
    remote_site_id: Optional[String] = None
    stored_id: Optional[ID] = Field(None, description="Set if studio matched")
    url: Optional[String] = None
    typename__: Optional[Literal["ScrapedStudio"]] = Field("ScrapedStudio", alias="__typename")


class ScrapedTag(BaseModel):
    name: String
    stored_id: Optional[ID] = Field(None, description="Set if tag matched")
    typename__: Optional[Literal["ScrapedTag"]] = Field("ScrapedTag", alias="__typename")


class Scraper(BaseModel):
    gallery: Optional[ScraperSpec] = Field(None, description="Details for gallery scraper")
    group: Optional[ScraperSpec] = Field(None, description="Details for group scraper")
    id: ID
    image: Optional[ScraperSpec] = Field(None, description="Details for image scraper")
    movie: Optional[ScraperSpec] = Field(None, description="Details for movie scraper")
    name: String
    performer: Optional[ScraperSpec] = Field(None, description="Details for performer scraper")
    scene: Optional[ScraperSpec] = Field(None, description="Details for scene scraper")
    typename__: Optional[Literal["Scraper"]] = Field("Scraper", alias="__typename")


class ScraperSource(BaseModel):
    scraper_id: Optional[ID] = Field(
        None, description="Scraper ID to scrape with. Should be unset if stash_box_endpoint/stash_box_index is set"
    )
    stash_box_endpoint: Optional[String] = Field(None, description="Stash-box endpoint")
    stash_box_index: Optional[Int] = Field(
        None, description="Index of the configured stash-box instance to use. Should be unset if scraper_id is set"
    )
    typename__: Optional[Literal["ScraperSource"]] = Field("ScraperSource", alias="__typename")


class ScraperSpec(BaseModel):
    supported_scrapes: List[ScrapeType]
    urls: Optional[List[String]] = Field(None, description="URLs matching these can be scraped with")
    typename__: Optional[Literal["ScraperSpec"]] = Field("ScraperSpec", alias="__typename")


class StashBox(BaseModel):
    api_key: String
    endpoint: String
    name: String
    typename__: Optional[Literal["StashBox"]] = Field("StashBox", alias="__typename")


class StashBoxFingerprint(BaseModel):
    algorithm: String
    duration: Int
    hash: String
    typename__: Optional[Literal["StashBoxFingerprint"]] = Field("StashBoxFingerprint", alias="__typename")


class StashBoxPerformerQueryResult(BaseModel):
    query: String
    results: List[ScrapedPerformer]
    typename__: Optional[Literal["StashBoxPerformerQueryResult"]] = Field(
        "StashBoxPerformerQueryResult", alias="__typename"
    )


class StashBoxValidationResult(BaseModel):
    status: String
    valid: Boolean
    typename__: Optional[Literal["StashBoxValidationResult"]] = Field("StashBoxValidationResult", alias="__typename")


class StashConfig(BaseModel):
    excludeImage: Boolean
    excludeVideo: Boolean
    path: String
    typename__: Optional[Literal["StashConfig"]] = Field("StashConfig", alias="__typename")


class StashID(BaseModel):
    endpoint: String
    stash_id: String
    updated_at: Time
    typename__: Optional[Literal["StashID"]] = Field("StashID", alias="__typename")


class StatsResultType(BaseModel):
    gallery_count: Int
    group_count: Int
    image_count: Int
    images_size: Float
    movie_count: Int
    performer_count: Int
    scene_count: Int
    scenes_duration: Float
    scenes_played: Int
    scenes_size: Float
    studio_count: Int
    tag_count: Int
    total_o_count: Int
    total_play_count: Int
    total_play_duration: Float
    typename__: Optional[Literal["StatsResultType"]] = Field("StatsResultType", alias="__typename")


class Studio(BaseModel):
    aliases: List[String]
    child_studios: List[Studio]
    created_at: Time
    details: Optional[String] = None
    favorite: Boolean
    gallery_count: Int
    group_count: Int
    groups: List[Group]
    id: ID
    ignore_auto_tag: Boolean
    image_count: Int
    image_path: Optional[String] = None
    movie_count: Int
    movies: List[Movie]
    name: String
    parent_studio: Optional[Studio] = None
    performer_count: Int
    rating100: Optional[Int] = None
    scene_count: Int
    stash_ids: List[StashID]
    tags: List[Tag]
    updated_at: Time
    url: Optional[String] = None
    typename__: Optional[Literal["Studio"]] = Field("Studio", alias="__typename")


class Subscription(BaseModel):
    jobsSubscribe: JobStatusUpdate = Field(..., description="Update from the metadata manager")
    loggingSubscribe: List[LogEntry]
    scanCompleteSubscribe: Boolean
    typename__: Optional[Literal["Subscription"]] = Field("Subscription", alias="__typename")


class SystemStatus(BaseModel):
    appSchema: Int
    configPath: Optional[String] = None
    databasePath: Optional[String] = None
    databaseSchema: Optional[Int] = None
    ffmpegPath: Optional[String] = None
    ffprobePath: Optional[String] = None
    homeDir: String
    os: String
    status: SystemStatusEnum
    workingDir: String
    typename__: Optional[Literal["SystemStatus"]] = Field("SystemStatus", alias="__typename")


class Tag(BaseModel):
    aliases: List[String]
    child_count: Int
    children: List[Tag]
    created_at: Time
    description: Optional[String] = None
    favorite: Boolean
    gallery_count: Int
    group_count: Int
    id: ID
    ignore_auto_tag: Boolean
    image_count: Int
    image_path: Optional[String] = None
    movie_count: Int
    name: String
    parent_count: Int
    parents: List[Tag]
    performer_count: Int
    scene_count: Int
    scene_marker_count: Int
    sort_name: Optional[String] = Field(
        None, description="Value that does not appear in the UI but overrides name for sorting"
    )
    studio_count: Int
    updated_at: Time
    typename__: Optional[Literal["Tag"]] = Field("Tag", alias="__typename")


class Version(BaseModel):
    build_time: String
    hash: String
    version: Optional[String] = None
    typename__: Optional[Literal["Version"]] = Field("Version", alias="__typename")


class VideoCaption(BaseModel):
    caption_type: String
    language_code: String
    typename__: Optional[Literal["VideoCaption"]] = Field("VideoCaption", alias="__typename")


class VideoFile(BaseFile):
    audio_codec: String
    basename: String
    bit_rate: Int
    created_at: Time
    duration: Float
    fingerprint: Optional[String] = None
    fingerprints: List[Fingerprint]
    format: String
    frame_rate: Float
    height: Int
    id: ID
    mod_time: Time
    parent_folder_id: ID
    path: String
    size: Int64
    updated_at: Time
    video_codec: String
    width: Int
    zip_file_id: Optional[ID] = None
    typename__: Optional[Literal["VideoFile"]] = Field("VideoFile", alias="__typename")  # type: ignore[assignment]


class AddTempDLNAIPInput(BaseModel):
    address: String
    duration: Optional[Int] = Field(None, description="Duration to enable, in minutes. 0 or null for indefinite.")
    typename__: Optional[Literal["AddTempDLNAIPInput"]] = Field("AddTempDLNAIPInput", alias="__typename")


class AnonymiseDatabaseInput(BaseModel):
    download: Optional[Boolean] = None
    typename__: Optional[Literal["AnonymiseDatabaseInput"]] = Field("AnonymiseDatabaseInput", alias="__typename")


class AssignSceneFileInput(BaseModel):
    file_id: ID
    scene_id: ID
    typename__: Optional[Literal["AssignSceneFileInput"]] = Field("AssignSceneFileInput", alias="__typename")


class AutoTagMetadataInput(BaseModel):
    paths: Optional[List[String]] = Field(None, description="Paths to tag, null for all files")
    performers: Optional[List[String]] = Field(None, description='IDs of performers to tag files with, or "*" for all')
    studios: Optional[List[String]] = Field(None, description='IDs of studios to tag files with, or "*" for all')
    tags: Optional[List[String]] = Field(None, description='IDs of tags to tag files with, or "*" for all')
    typename__: Optional[Literal["AutoTagMetadataInput"]] = Field("AutoTagMetadataInput", alias="__typename")


class BackupDatabaseInput(BaseModel):
    download: Optional[Boolean] = None
    typename__: Optional[Literal["BackupDatabaseInput"]] = Field("BackupDatabaseInput", alias="__typename")


class BulkGalleryUpdateInput(BaseModel):
    clientMutationId: Optional[String] = None
    code: Optional[String] = None
    date: Optional[String] = None
    details: Optional[String] = None
    ids: Optional[List[ID]] = None
    organized: Optional[Boolean] = None
    performer_ids: Optional[BulkUpdateIds] = None
    photographer: Optional[String] = None
    rating100: Optional[Int] = None
    scene_ids: Optional[BulkUpdateIds] = None
    studio_id: Optional[ID] = None
    tag_ids: Optional[BulkUpdateIds] = None
    url: Optional[String] = None
    urls: Optional[BulkUpdateStrings] = None
    typename__: Optional[Literal["BulkGalleryUpdateInput"]] = Field("BulkGalleryUpdateInput", alias="__typename")


class BulkGroupUpdateInput(BaseModel):
    clientMutationId: Optional[String] = None
    containing_groups: Optional[BulkUpdateGroupDescriptionsInput] = None
    director: Optional[String] = None
    ids: Optional[List[ID]] = None
    rating100: Optional[Int] = None
    studio_id: Optional[ID] = None
    sub_groups: Optional[BulkUpdateGroupDescriptionsInput] = None
    tag_ids: Optional[BulkUpdateIds] = None
    urls: Optional[BulkUpdateStrings] = None
    typename__: Optional[Literal["BulkGroupUpdateInput"]] = Field("BulkGroupUpdateInput", alias="__typename")


class BulkImageUpdateInput(BaseModel):
    clientMutationId: Optional[String] = None
    code: Optional[String] = None
    date: Optional[String] = None
    details: Optional[String] = None
    gallery_ids: Optional[BulkUpdateIds] = None
    ids: Optional[List[ID]] = None
    organized: Optional[Boolean] = None
    performer_ids: Optional[BulkUpdateIds] = None
    photographer: Optional[String] = None
    rating100: Optional[Int] = None
    studio_id: Optional[ID] = None
    tag_ids: Optional[BulkUpdateIds] = None
    title: Optional[String] = None
    url: Optional[String] = None
    urls: Optional[BulkUpdateStrings] = None
    typename__: Optional[Literal["BulkImageUpdateInput"]] = Field("BulkImageUpdateInput", alias="__typename")


class BulkMovieUpdateInput(BaseModel):
    clientMutationId: Optional[String] = None
    director: Optional[String] = None
    ids: Optional[List[ID]] = None
    rating100: Optional[Int] = None
    studio_id: Optional[ID] = None
    tag_ids: Optional[BulkUpdateIds] = None
    urls: Optional[BulkUpdateStrings] = None
    typename__: Optional[Literal["BulkMovieUpdateInput"]] = Field("BulkMovieUpdateInput", alias="__typename")


class BulkPerformerUpdateInput(BaseModel):
    alias_list: Optional[BulkUpdateStrings] = None
    birthdate: Optional[String] = None
    career_length: Optional[String] = None
    circumcised: Optional[CircumisedEnum] = None
    clientMutationId: Optional[String] = None
    country: Optional[String] = None
    custom_fields: Optional[CustomFieldsInput] = None
    death_date: Optional[String] = None
    details: Optional[String] = None
    disambiguation: Optional[String] = None
    ethnicity: Optional[String] = None
    eye_color: Optional[String] = None
    fake_tits: Optional[String] = None
    favorite: Optional[Boolean] = None
    gender: Optional[GenderEnum] = None
    hair_color: Optional[String] = None
    height_cm: Optional[Int] = None
    ids: Optional[List[ID]] = None
    ignore_auto_tag: Optional[Boolean] = None
    instagram: Optional[String] = None
    measurements: Optional[String] = None
    penis_length: Optional[Float] = None
    piercings: Optional[String] = None
    rating100: Optional[Int] = None
    tag_ids: Optional[BulkUpdateIds] = None
    tattoos: Optional[String] = None
    twitter: Optional[String] = None
    url: Optional[String] = None
    urls: Optional[BulkUpdateStrings] = None
    weight: Optional[Int] = None
    typename__: Optional[Literal["BulkPerformerUpdateInput"]] = Field("BulkPerformerUpdateInput", alias="__typename")


class BulkSceneUpdateInput(BaseModel):
    clientMutationId: Optional[String] = None
    code: Optional[String] = None
    date: Optional[String] = None
    details: Optional[String] = None
    director: Optional[String] = None
    gallery_ids: Optional[BulkUpdateIds] = None
    group_ids: Optional[BulkUpdateIds] = None
    ids: Optional[List[ID]] = None
    movie_ids: Optional[BulkUpdateIds] = None
    organized: Optional[Boolean] = None
    performer_ids: Optional[BulkUpdateIds] = None
    rating100: Optional[Int] = None
    studio_id: Optional[ID] = None
    tag_ids: Optional[BulkUpdateIds] = None
    title: Optional[String] = None
    url: Optional[String] = None
    urls: Optional[BulkUpdateStrings] = None
    typename__: Optional[Literal["BulkSceneUpdateInput"]] = Field("BulkSceneUpdateInput", alias="__typename")


class BulkTagUpdateInput(BaseModel):
    aliases: Optional[BulkUpdateStrings] = None
    child_ids: Optional[BulkUpdateIds] = None
    description: Optional[String] = None
    favorite: Optional[Boolean] = None
    ids: Optional[List[ID]] = None
    ignore_auto_tag: Optional[Boolean] = None
    parent_ids: Optional[BulkUpdateIds] = None
    typename__: Optional[Literal["BulkTagUpdateInput"]] = Field("BulkTagUpdateInput", alias="__typename")


class BulkUpdateGroupDescriptionsInput(BaseModel):
    groups: List[GroupDescriptionInput]
    mode: BulkUpdateIdMode
    typename__: Optional[Literal["BulkUpdateGroupDescriptionsInput"]] = Field(
        "BulkUpdateGroupDescriptionsInput", alias="__typename"
    )


class BulkUpdateIds(BaseModel):
    ids: Optional[List[ID]] = None
    mode: BulkUpdateIdMode
    typename__: Optional[Literal["BulkUpdateIds"]] = Field("BulkUpdateIds", alias="__typename")


class BulkUpdateStrings(BaseModel):
    mode: BulkUpdateIdMode
    values: Optional[List[String]] = None
    typename__: Optional[Literal["BulkUpdateStrings"]] = Field("BulkUpdateStrings", alias="__typename")


class CircumcisionCriterionInput(BaseModel):
    modifier: CriterionModifier
    value: Optional[List[CircumisedEnum]] = None
    typename__: Optional[Literal["CircumcisionCriterionInput"]] = Field(
        "CircumcisionCriterionInput", alias="__typename"
    )


class CleanGeneratedInput(BaseModel):
    blobFiles: Optional[Boolean] = Field(None, description="Clean blob files without blob entries")
    dryRun: Optional[Boolean] = Field(None, description="Do a dry run. Don't delete any files")
    imageThumbnails: Optional[Boolean] = Field(None, description="Clean image thumbnails/clips without image entries")
    markers: Optional[Boolean] = Field(None, description="Clean marker files without marker entries")
    screenshots: Optional[Boolean] = Field(None, description="Clean preview files without scene entries")
    sprites: Optional[Boolean] = Field(None, description="Clean sprite and vtt files without scene entries")
    transcodes: Optional[Boolean] = Field(None, description="Clean scene transcodes without scene entries")
    typename__: Optional[Literal["CleanGeneratedInput"]] = Field("CleanGeneratedInput", alias="__typename")


class CleanMetadataInput(BaseModel):
    dryRun: Boolean = Field(..., description="Do a dry run. Don't delete any files")
    paths: Optional[List[String]] = None
    typename__: Optional[Literal["CleanMetadataInput"]] = Field("CleanMetadataInput", alias="__typename")


class ConfigDLNAInput(BaseModel):
    enabled: Optional[Boolean] = Field(None, description="True if DLNA service should be enabled by default")
    interfaces: Optional[List[String]] = Field(None, description="List of interfaces to run DLNA on. Empty for all")
    port: Optional[Int] = Field(None, description="Defaults to 1338")
    serverName: Optional[String] = None
    videoSortOrder: Optional[String] = Field(None, description="Order to sort videos")
    whitelistedIPs: Optional[List[String]] = Field(None, description="List of IPs whitelisted for DLNA service")
    typename__: Optional[Literal["ConfigDLNAInput"]] = Field("ConfigDLNAInput", alias="__typename")


class ConfigDefaultSettingsInput(BaseModel):
    autoTag: Optional[AutoTagMetadataInput] = None
    deleteFile: Optional[Boolean] = Field(None, description="If true, delete file checkbox will be checked by default")
    deleteGenerated: Optional[Boolean] = Field(
        None, description="If true, delete generated files checkbox will be checked by default"
    )
    generate: Optional[GenerateMetadataInput] = None
    identify: Optional[IdentifyMetadataInput] = None
    scan: Optional[ScanMetadataInput] = None
    typename__: Optional[Literal["ConfigDefaultSettingsInput"]] = Field(
        "ConfigDefaultSettingsInput", alias="__typename"
    )


class ConfigDisableDropdownCreateInput(BaseModel):
    movie: Optional[Boolean] = None
    performer: Optional[Boolean] = None
    studio: Optional[Boolean] = None
    tag: Optional[Boolean] = None
    typename__: Optional[Literal["ConfigDisableDropdownCreateInput"]] = Field(
        "ConfigDisableDropdownCreateInput", alias="__typename"
    )


class ConfigGeneralInput(BaseModel):
    backupDirectoryPath: Optional[String] = Field(None, description="Path to backup directory")
    blobsPath: Optional[String] = Field(None, description="Path to blobs - required for filesystem blob storage")
    blobsStorage: Optional[BlobsStorageType] = Field(None, description="Where to store blobs")
    cachePath: Optional[String] = Field(None, description="Path to cache")
    calculateMD5: Optional[Boolean] = Field(
        None, description="Whether to calculate MD5 checksums for scene video files"
    )
    createGalleriesFromFolders: Optional[Boolean] = Field(
        None, description="True if galleries should be created from folders with images"
    )
    createImageClipsFromVideos: Optional[Boolean] = Field(
        None, description="Create Image Clips from Video extensions when Videos are disabled in Library"
    )
    customPerformerImageLocation: Optional[String] = Field(None, description="Custom Performer Image Location")
    databasePath: Optional[String] = Field(None, description="Path to the SQLite database")
    drawFunscriptHeatmapRange: Optional[Boolean] = Field(
        None, description="whether to include range in generated funscript heatmaps"
    )
    excludes: Optional[List[String]] = Field(None, description="Array of file regexp to exclude from Video Scans")
    ffmpegPath: Optional[String] = Field(
        None,
        description="Path to the ffmpeg binary. If empty, stash will attempt to find it in the path or config directory",
    )
    ffprobePath: Optional[String] = Field(
        None,
        description="Path to the ffprobe binary. If empty, stash will attempt to find it in the path or config directory",
    )
    galleryCoverRegex: Optional[String] = Field(None, description="Regex used to identify images as gallery covers")
    galleryExtensions: Optional[List[String]] = Field(None, description="Array of gallery zip file extensions")
    generatedPath: Optional[String] = Field(None, description="Path to generated files")
    imageExcludes: Optional[List[String]] = Field(None, description="Array of file regexp to exclude from Image Scans")
    imageExtensions: Optional[List[String]] = Field(None, description="Array of image file extensions")
    liveTranscodeInputArgs: Optional[List[String]] = Field(
        None,
        description="ffmpeg stream input args - injected before input file\nThese are applied when live transcoding",
    )
    liveTranscodeOutputArgs: Optional[List[String]] = Field(
        None,
        description="ffmpeg stream output args - injected before output file\nThese are applied when live transcoding",
    )
    logAccess: Optional[Boolean] = Field(None, description="Whether to log http access")
    logFile: Optional[String] = Field(None, description="Name of the log file")
    logLevel: Optional[String] = Field(None, description="Minimum log level")
    logOut: Optional[Boolean] = Field(None, description="Whether to also output to stderr")
    maxSessionAge: Optional[Int] = Field(None, description="Maximum session cookie age")
    maxStreamingTranscodeSize: Optional[StreamingResolutionEnum] = Field(
        None, description="Max streaming transcode size"
    )
    maxTranscodeSize: Optional[StreamingResolutionEnum] = Field(None, description="Max generated transcode size")
    metadataPath: Optional[String] = Field(None, description="Path to import/export files")
    parallelTasks: Optional[Int] = Field(None, description="Number of parallel tasks to start during scan/generate")
    password: Optional[String] = Field(None, description="Password")
    pluginPackageSources: Optional[List[PackageSourceInput]] = Field(None, description="Source of plugin packages")
    pluginsPath: Optional[String] = Field(None, description="Path to plugins")
    previewAudio: Optional[Boolean] = Field(None, description="Include audio stream in previews")
    previewExcludeEnd: Optional[String] = Field(
        None, description="Duration of end of video to exclude when generating previews"
    )
    previewExcludeStart: Optional[String] = Field(
        None, description="Duration of start of video to exclude when generating previews"
    )
    previewPreset: Optional[PreviewPreset] = Field(None, description="Preset when generating preview")
    previewSegmentDuration: Optional[Float] = Field(None, description="Preview segment duration, in seconds")
    previewSegments: Optional[Int] = Field(None, description="Number of segments in a preview file")
    pythonPath: Optional[String] = Field(None, description="Python path - resolved using path if unset")
    scraperPackageSources: Optional[List[PackageSourceInput]] = Field(None, description="Source of scraper packages")
    scrapersPath: Optional[String] = Field(None, description="Path to scrapers")
    stashBoxes: Optional[List[StashBoxInput]] = Field(None, description="Stash-box instances used for tagging")
    stashes: Optional[List[StashConfigInput]] = Field(None, description="Array of file paths to content")
    transcodeHardwareAcceleration: Optional[Boolean] = Field(None, description="Transcode Hardware Acceleration")
    transcodeInputArgs: Optional[List[String]] = Field(
        None,
        description="ffmpeg transcode input args - injected before input file\nThese are applied to generated transcodes (previews and transcodes)",
    )
    transcodeOutputArgs: Optional[List[String]] = Field(
        None,
        description="ffmpeg transcode output args - injected before output file\nThese are applied to generated transcodes (previews and transcodes)",
    )
    username: Optional[String] = Field(None, description="Username")
    videoExtensions: Optional[List[String]] = Field(None, description="Array of video file extensions")
    videoFileNamingAlgorithm: Optional[HashAlgorithm] = Field(
        None, description="Hash algorithm to use for generated file naming"
    )
    writeImageThumbnails: Optional[Boolean] = Field(
        None, description="Write image thumbnails to disk when generating on the fly"
    )
    typename__: Optional[Literal["ConfigGeneralInput"]] = Field("ConfigGeneralInput", alias="__typename")


class ConfigImageLightboxInput(BaseModel):
    displayMode: Optional[ImageLightboxDisplayMode] = None
    resetZoomOnNav: Optional[Boolean] = None
    scaleUp: Optional[Boolean] = None
    scrollAttemptsBeforeChange: Optional[Int] = None
    scrollMode: Optional[ImageLightboxScrollMode] = None
    slideshowDelay: Optional[Int] = None
    typename__: Optional[Literal["ConfigImageLightboxInput"]] = Field("ConfigImageLightboxInput", alias="__typename")


class ConfigInterfaceInput(BaseModel):
    autostartVideo: Optional[Boolean] = Field(
        None, description="If true, video will autostart on load in the scene player"
    )
    autostartVideoOnPlaySelected: Optional[Boolean] = Field(
        None, description="If true, video will autostart when loading from play random or play selected"
    )
    continuePlaylistDefault: Optional[Boolean] = Field(
        None, description="If true, next scene in playlist will be played at video end by default"
    )
    css: Optional[String] = Field(None, description="Custom CSS")
    cssEnabled: Optional[Boolean] = None
    customLocales: Optional[String] = Field(None, description="Custom Locales")
    customLocalesEnabled: Optional[Boolean] = None
    disableDropdownCreate: Optional[ConfigDisableDropdownCreateInput] = Field(
        None, description="Set to true to disable creating new objects via the dropdown menus"
    )
    funscriptOffset: Optional[Int] = Field(None, description="Funscript Time Offset")
    handyKey: Optional[String] = Field(None, description="Handy Connection Key")
    imageLightbox: Optional[ConfigImageLightboxInput] = None
    javascript: Optional[String] = Field(None, description="Custom Javascript")
    javascriptEnabled: Optional[Boolean] = None
    language: Optional[String] = Field(None, description="Interface language")
    maximumLoopDuration: Optional[Int] = Field(
        None, description="Maximum duration (in seconds) in which a scene video will loop in the scene player"
    )
    menuItems: Optional[List[String]] = Field(
        None, description="Ordered list of items that should be shown in the menu"
    )
    noBrowser: Optional[Boolean] = Field(
        None, description="True if we should not auto-open a browser window on startup"
    )
    notificationsEnabled: Optional[Boolean] = Field(
        None, description="True if we should send notifications to the desktop"
    )
    showScrubber: Optional[Boolean] = Field(None, description="Show scene scrubber by default")
    showStudioAsText: Optional[Boolean] = Field(
        None, description="If true, studio overlays will be shown as text instead of logo images"
    )
    soundOnPreview: Optional[Boolean] = Field(None, description="Enable sound on mouseover previews")
    useStashHostedFunscript: Optional[Boolean] = Field(None, description="Whether to use Stash Hosted Funscript")
    wallPlayback: Optional[String] = Field(None, description="Wall playback type")
    wallShowTitle: Optional[Boolean] = Field(None, description="Show title and tags in wall view")
    typename__: Optional[Literal["ConfigInterfaceInput"]] = Field("ConfigInterfaceInput", alias="__typename")


class ConfigScrapingInput(BaseModel):
    excludeTagPatterns: Optional[List[String]] = Field(None, description="Tags blacklist during scraping")
    scraperCDPPath: Optional[String] = Field(
        None, description="Scraper CDP path. Path to chrome executable or remote address"
    )
    scraperCertCheck: Optional[Boolean] = Field(
        None, description="Whether the scraper should check for invalid certificates"
    )
    scraperUserAgent: Optional[String] = Field(None, description="Scraper user agent string")
    typename__: Optional[Literal["ConfigScrapingInput"]] = Field("ConfigScrapingInput", alias="__typename")


class CustomFieldCriterionInput(BaseModel):
    field: String
    modifier: CriterionModifier
    value: Optional[List[Any]] = None
    typename__: Optional[Literal["CustomFieldCriterionInput"]] = Field("CustomFieldCriterionInput", alias="__typename")


class CustomFieldsInput(BaseModel):
    full: Optional[Map] = Field(
        None, description="If populated, the entire custom fields map will be replaced with this value"
    )
    partial: Optional[Map] = Field(None, description="If populated, only the keys in this map will be updated")
    typename__: Optional[Literal["CustomFieldsInput"]] = Field("CustomFieldsInput", alias="__typename")


class DateCriterionInput(BaseModel):
    modifier: CriterionModifier
    value: String
    value2: Optional[String] = None
    typename__: Optional[Literal["DateCriterionInput"]] = Field("DateCriterionInput", alias="__typename")


class DestroyFilterInput(BaseModel):
    id: ID
    typename__: Optional[Literal["DestroyFilterInput"]] = Field("DestroyFilterInput", alias="__typename")


class DisableDLNAInput(BaseModel):
    duration: Optional[Int] = Field(None, description="Duration to enable, in minutes. 0 or null for indefinite.")
    typename__: Optional[Literal["DisableDLNAInput"]] = Field("DisableDLNAInput", alias="__typename")


class EnableDLNAInput(BaseModel):
    duration: Optional[Int] = Field(None, description="Duration to enable, in minutes. 0 or null for indefinite.")
    typename__: Optional[Literal["EnableDLNAInput"]] = Field("EnableDLNAInput", alias="__typename")


class ExportObjectTypeInput(BaseModel):
    all: Optional[Boolean] = None
    ids: Optional[List[String]] = None
    typename__: Optional[Literal["ExportObjectTypeInput"]] = Field("ExportObjectTypeInput", alias="__typename")


class ExportObjectsInput(BaseModel):
    galleries: Optional[ExportObjectTypeInput] = None
    groups: Optional[ExportObjectTypeInput] = None
    images: Optional[ExportObjectTypeInput] = None
    includeDependencies: Optional[Boolean] = None
    movies: Optional[ExportObjectTypeInput] = None
    performers: Optional[ExportObjectTypeInput] = None
    scenes: Optional[ExportObjectTypeInput] = None
    studios: Optional[ExportObjectTypeInput] = None
    tags: Optional[ExportObjectTypeInput] = None
    typename__: Optional[Literal["ExportObjectsInput"]] = Field("ExportObjectsInput", alias="__typename")


class FileSetFingerprintsInput(BaseModel):
    fingerprints: List[SetFingerprintsInput] = Field(
        ..., description="only supplied fingerprint types will be modified"
    )
    id: ID
    typename__: Optional[Literal["FileSetFingerprintsInput"]] = Field("FileSetFingerprintsInput", alias="__typename")


class FindFilterType(BaseModel):
    direction: Optional[SortDirectionEnum] = None
    page: Optional[Int] = None
    per_page: Optional[Int] = Field(None, description="use per_page = -1 to indicate all results. Defaults to 25.")
    q: Optional[String] = None
    sort: Optional[String] = None
    typename__: Optional[Literal["FindFilterType"]] = Field("FindFilterType", alias="__typename")


class FindJobInput(BaseModel):
    id: ID
    typename__: Optional[Literal["FindJobInput"]] = Field("FindJobInput", alias="__typename")


class FloatCriterionInput(BaseModel):
    modifier: CriterionModifier
    value: Float
    value2: Optional[Float] = None
    typename__: Optional[Literal["FloatCriterionInput"]] = Field("FloatCriterionInput", alias="__typename")


class GalleryAddInput(BaseModel):
    gallery_id: ID
    image_ids: List[ID]
    typename__: Optional[Literal["GalleryAddInput"]] = Field("GalleryAddInput", alias="__typename")


class GalleryChapterCreateInput(BaseModel):
    gallery_id: ID
    image_index: Int
    title: String
    typename__: Optional[Literal["GalleryChapterCreateInput"]] = Field("GalleryChapterCreateInput", alias="__typename")


class GalleryChapterUpdateInput(BaseModel):
    gallery_id: Optional[ID] = None
    id: ID
    image_index: Optional[Int] = None
    title: Optional[String] = None
    typename__: Optional[Literal["GalleryChapterUpdateInput"]] = Field("GalleryChapterUpdateInput", alias="__typename")


class GalleryCreateInput(BaseModel):
    code: Optional[String] = None
    date: Optional[String] = None
    details: Optional[String] = None
    organized: Optional[Boolean] = None
    performer_ids: Optional[List[ID]] = None
    photographer: Optional[String] = None
    rating100: Optional[Int] = None
    scene_ids: Optional[List[ID]] = None
    studio_id: Optional[ID] = None
    tag_ids: Optional[List[ID]] = None
    title: String
    url: Optional[String] = None
    urls: Optional[List[String]] = None
    typename__: Optional[Literal["GalleryCreateInput"]] = Field("GalleryCreateInput", alias="__typename")


class GalleryDestroyInput(BaseModel):
    delete_file: Optional[Boolean] = Field(
        None,
        description="If true, then the zip file will be deleted if the gallery is zip-file-based.\nIf gallery is folder-based, then any files not associated with other\ngalleries will be deleted, along with the folder, if it is not empty.",
    )
    delete_generated: Optional[Boolean] = None
    ids: List[ID]
    typename__: Optional[Literal["GalleryDestroyInput"]] = Field("GalleryDestroyInput", alias="__typename")


class GalleryFilterType(BaseModel):
    AND: Optional[GalleryFilterType] = None
    NOT: Optional[GalleryFilterType] = None
    OR: Optional[GalleryFilterType] = None
    average_resolution: Optional[ResolutionCriterionInput] = Field(
        None, description="Filter by average image resolution"
    )
    checksum: Optional[StringCriterionInput] = Field(None, description="Filter by file checksum")
    code: Optional[StringCriterionInput] = Field(None, description="Filter by studio code")
    created_at: Optional[TimestampCriterionInput] = Field(None, description="Filter by creation time")
    date: Optional[DateCriterionInput] = Field(None, description="Filter by date")
    details: Optional[StringCriterionInput] = None
    file_count: Optional[IntCriterionInput] = Field(None, description="Filter by zip-file count")
    has_chapters: Optional[String] = Field(
        None, description="Filter to only include galleries that have chapters. `true` or `false`"
    )
    id: Optional[IntCriterionInput] = None
    image_count: Optional[IntCriterionInput] = Field(None, description="Filter by number of images in this gallery")
    images_filter: Optional[ImageFilterType] = Field(
        None, description="Filter by related images that meet this criteria"
    )
    is_missing: Optional[String] = Field(None, description="Filter to only include galleries missing this property")
    is_zip: Optional[Boolean] = Field(
        None, description="Filter to include/exclude galleries that were created from zip"
    )
    organized: Optional[Boolean] = Field(None, description="Filter by organized")
    path: Optional[StringCriterionInput] = Field(None, description="Filter by path")
    performer_age: Optional[IntCriterionInput] = Field(
        None, description="Filter galleries by performer age at time of gallery"
    )
    performer_count: Optional[IntCriterionInput] = Field(None, description="Filter by performer count")
    performer_favorite: Optional[Boolean] = Field(
        None, description="Filter galleries that have performers that have been favorited"
    )
    performer_tags: Optional[HierarchicalMultiCriterionInput] = Field(
        None, description="Filter to only include galleries with performers with these tags"
    )
    performers: Optional[MultiCriterionInput] = Field(
        None, description="Filter to only include galleries with these performers"
    )
    performers_filter: Optional[PerformerFilterType] = Field(
        None, description="Filter by related performers that meet this criteria"
    )
    photographer: Optional[StringCriterionInput] = Field(None, description="Filter by photographer")
    rating100: Optional[IntCriterionInput] = None
    scenes: Optional[MultiCriterionInput] = Field(
        None, description="Filter to only include galleries with these scenes"
    )
    scenes_filter: Optional[SceneFilterType] = Field(
        None, description="Filter by related scenes that meet this criteria"
    )
    studios: Optional[HierarchicalMultiCriterionInput] = Field(
        None, description="Filter to only include galleries with this studio"
    )
    studios_filter: Optional[StudioFilterType] = Field(
        None, description="Filter by related studios that meet this criteria"
    )
    tag_count: Optional[IntCriterionInput] = Field(None, description="Filter by tag count")
    tags: Optional[HierarchicalMultiCriterionInput] = Field(
        None, description="Filter to only include galleries with these tags"
    )
    tags_filter: Optional[TagFilterType] = Field(None, description="Filter by related tags that meet this criteria")
    title: Optional[StringCriterionInput] = None
    updated_at: Optional[TimestampCriterionInput] = Field(None, description="Filter by last update time")
    url: Optional[StringCriterionInput] = Field(None, description="Filter by url")
    typename__: Optional[Literal["GalleryFilterType"]] = Field("GalleryFilterType", alias="__typename")


class GalleryRemoveInput(BaseModel):
    gallery_id: ID
    image_ids: List[ID]
    typename__: Optional[Literal["GalleryRemoveInput"]] = Field("GalleryRemoveInput", alias="__typename")


class GalleryResetCoverInput(BaseModel):
    gallery_id: ID
    typename__: Optional[Literal["GalleryResetCoverInput"]] = Field("GalleryResetCoverInput", alias="__typename")


class GallerySetCoverInput(BaseModel):
    cover_image_id: ID
    gallery_id: ID
    typename__: Optional[Literal["GallerySetCoverInput"]] = Field("GallerySetCoverInput", alias="__typename")


class GalleryUpdateInput(BaseModel):
    clientMutationId: Optional[String] = None
    code: Optional[String] = None
    date: Optional[String] = None
    details: Optional[String] = None
    id: ID
    organized: Optional[Boolean] = None
    performer_ids: Optional[List[ID]] = None
    photographer: Optional[String] = None
    primary_file_id: Optional[ID] = None
    rating100: Optional[Int] = None
    scene_ids: Optional[List[ID]] = None
    studio_id: Optional[ID] = None
    tag_ids: Optional[List[ID]] = None
    title: Optional[String] = None
    url: Optional[String] = None
    urls: Optional[List[String]] = None
    typename__: Optional[Literal["GalleryUpdateInput"]] = Field("GalleryUpdateInput", alias="__typename")


class GenderCriterionInput(BaseModel):
    modifier: CriterionModifier
    value: Optional[GenderEnum] = None
    value_list: Optional[List[GenderEnum]] = None
    typename__: Optional[Literal["GenderCriterionInput"]] = Field("GenderCriterionInput", alias="__typename")


class GenerateAPIKeyInput(BaseModel):
    clear: Optional[Boolean] = None
    typename__: Optional[Literal["GenerateAPIKeyInput"]] = Field("GenerateAPIKeyInput", alias="__typename")


class GenerateMetadataInput(BaseModel):
    clipPreviews: Optional[Boolean] = None
    covers: Optional[Boolean] = None
    forceTranscodes: Optional[Boolean] = Field(None, description="Generate transcodes even if not required")
    imagePreviews: Optional[Boolean] = None
    imageThumbnails: Optional[Boolean] = None
    interactiveHeatmapsSpeeds: Optional[Boolean] = None
    markerIDs: Optional[List[ID]] = Field(None, description="marker ids to generate for")
    markerImagePreviews: Optional[Boolean] = None
    markerScreenshots: Optional[Boolean] = None
    markers: Optional[Boolean] = None
    overwrite: Optional[Boolean] = Field(None, description="overwrite existing media")
    phashes: Optional[Boolean] = None
    previewOptions: Optional[GeneratePreviewOptionsInput] = None
    previews: Optional[Boolean] = None
    sceneIDs: Optional[List[ID]] = Field(None, description="scene ids to generate for")
    sprites: Optional[Boolean] = None
    transcodes: Optional[Boolean] = None
    typename__: Optional[Literal["GenerateMetadataInput"]] = Field("GenerateMetadataInput", alias="__typename")


class GeneratePreviewOptionsInput(BaseModel):
    previewExcludeEnd: Optional[String] = Field(
        None, description="Duration of end of video to exclude when generating previews"
    )
    previewExcludeStart: Optional[String] = Field(
        None, description="Duration of start of video to exclude when generating previews"
    )
    previewPreset: Optional[PreviewPreset] = Field(None, description="Preset when generating preview")
    previewSegmentDuration: Optional[Float] = Field(None, description="Preview segment duration, in seconds")
    previewSegments: Optional[Int] = Field(None, description="Number of segments in a preview file")
    typename__: Optional[Literal["GeneratePreviewOptionsInput"]] = Field(
        "GeneratePreviewOptionsInput", alias="__typename"
    )


class GroupCreateInput(BaseModel):
    aliases: Optional[String] = None
    back_image: Optional[String] = Field(None, description="This should be a URL or a base64 encoded data URL")
    containing_groups: Optional[List[GroupDescriptionInput]] = None
    date: Optional[String] = None
    director: Optional[String] = None
    duration: Optional[Int] = Field(None, description="Duration in seconds")
    front_image: Optional[String] = Field(None, description="This should be a URL or a base64 encoded data URL")
    name: String
    rating100: Optional[Int] = None
    studio_id: Optional[ID] = None
    sub_groups: Optional[List[GroupDescriptionInput]] = None
    synopsis: Optional[String] = None
    tag_ids: Optional[List[ID]] = None
    urls: Optional[List[String]] = None
    typename__: Optional[Literal["GroupCreateInput"]] = Field("GroupCreateInput", alias="__typename")


class GroupDescriptionInput(BaseModel):
    description: Optional[String] = None
    group_id: ID
    typename__: Optional[Literal["GroupDescriptionInput"]] = Field("GroupDescriptionInput", alias="__typename")


class GroupDestroyInput(BaseModel):
    id: ID
    typename__: Optional[Literal["GroupDestroyInput"]] = Field("GroupDestroyInput", alias="__typename")


class GroupFilterType(BaseModel):
    AND: Optional[GroupFilterType] = None
    NOT: Optional[GroupFilterType] = None
    OR: Optional[GroupFilterType] = None
    containing_group_count: Optional[IntCriterionInput] = Field(
        None, description="Filter by number of containing groups the group has"
    )
    containing_groups: Optional[HierarchicalMultiCriterionInput] = Field(
        None, description="Filter by containing groups"
    )
    created_at: Optional[TimestampCriterionInput] = Field(None, description="Filter by creation time")
    date: Optional[DateCriterionInput] = Field(None, description="Filter by date")
    director: Optional[StringCriterionInput] = None
    duration: Optional[IntCriterionInput] = Field(None, description="Filter by duration (in seconds)")
    is_missing: Optional[String] = Field(None, description="Filter to only include groups missing this property")
    name: Optional[StringCriterionInput] = None
    performers: Optional[MultiCriterionInput] = Field(
        None, description="Filter to only include groups where performer appears in a scene"
    )
    rating100: Optional[IntCriterionInput] = None
    scenes_filter: Optional[SceneFilterType] = Field(
        None, description="Filter by related scenes that meet this criteria"
    )
    studios: Optional[HierarchicalMultiCriterionInput] = Field(
        None, description="Filter to only include groups with this studio"
    )
    studios_filter: Optional[StudioFilterType] = Field(
        None, description="Filter by related studios that meet this criteria"
    )
    sub_group_count: Optional[IntCriterionInput] = Field(
        None, description="Filter by number of sub-groups the group has"
    )
    sub_groups: Optional[HierarchicalMultiCriterionInput] = Field(None, description="Filter by sub groups")
    synopsis: Optional[StringCriterionInput] = None
    tag_count: Optional[IntCriterionInput] = Field(None, description="Filter by tag count")
    tags: Optional[HierarchicalMultiCriterionInput] = Field(
        None, description="Filter to only include groups with these tags"
    )
    updated_at: Optional[TimestampCriterionInput] = Field(None, description="Filter by last update time")
    url: Optional[StringCriterionInput] = Field(None, description="Filter by url")
    typename__: Optional[Literal["GroupFilterType"]] = Field("GroupFilterType", alias="__typename")


class GroupSubGroupAddInput(BaseModel):
    containing_group_id: ID
    insert_index: Optional[Int] = Field(
        None,
        description="The index at which to insert the sub groups. If not provided, the sub groups will be appended to the end",
    )
    sub_groups: List[GroupDescriptionInput]
    typename__: Optional[Literal["GroupSubGroupAddInput"]] = Field("GroupSubGroupAddInput", alias="__typename")


class GroupSubGroupRemoveInput(BaseModel):
    containing_group_id: ID
    sub_group_ids: List[ID]
    typename__: Optional[Literal["GroupSubGroupRemoveInput"]] = Field("GroupSubGroupRemoveInput", alias="__typename")


class GroupUpdateInput(BaseModel):
    aliases: Optional[String] = None
    back_image: Optional[String] = Field(None, description="This should be a URL or a base64 encoded data URL")
    containing_groups: Optional[List[GroupDescriptionInput]] = None
    date: Optional[String] = None
    director: Optional[String] = None
    duration: Optional[Int] = None
    front_image: Optional[String] = Field(None, description="This should be a URL or a base64 encoded data URL")
    id: ID
    name: Optional[String] = None
    rating100: Optional[Int] = None
    studio_id: Optional[ID] = None
    sub_groups: Optional[List[GroupDescriptionInput]] = None
    synopsis: Optional[String] = None
    tag_ids: Optional[List[ID]] = None
    urls: Optional[List[String]] = None
    typename__: Optional[Literal["GroupUpdateInput"]] = Field("GroupUpdateInput", alias="__typename")


class HierarchicalMultiCriterionInput(BaseModel):
    depth: Optional[Int] = None
    excludes: Optional[List[ID]] = None
    modifier: CriterionModifier
    value: Optional[List[ID]] = None
    typename__: Optional[Literal["HierarchicalMultiCriterionInput"]] = Field(
        "HierarchicalMultiCriterionInput", alias="__typename"
    )


class IdentifyFieldOptionsInput(BaseModel):
    createMissing: Optional[Boolean] = Field(
        None, description="creates missing objects if needed - only applicable for performers, tags and studios"
    )
    field: String
    strategy: IdentifyFieldStrategy
    typename__: Optional[Literal["IdentifyFieldOptionsInput"]] = Field("IdentifyFieldOptionsInput", alias="__typename")


class IdentifyMetadataInput(BaseModel):
    options: Optional[IdentifyMetadataOptionsInput] = Field(
        None, description="Options defined here override the configured defaults"
    )
    paths: Optional[List[String]] = Field(
        None, description="paths of scenes to identify - ignored if scene ids are set"
    )
    sceneIDs: Optional[List[ID]] = Field(None, description="scene ids to identify")
    sources: List[IdentifySourceInput] = Field(
        ...,
        description="An ordered list of sources to identify items with. Only the first source that finds a match is used.",
    )
    typename__: Optional[Literal["IdentifyMetadataInput"]] = Field("IdentifyMetadataInput", alias="__typename")


class IdentifyMetadataOptionsInput(BaseModel):
    fieldOptions: Optional[List[IdentifyFieldOptionsInput]] = Field(
        None, description="any fields missing from here are defaulted to MERGE and createMissing false"
    )
    includeMalePerformers: Optional[Boolean] = Field(None, description="defaults to true if not provided")
    setCoverImage: Optional[Boolean] = Field(None, description="defaults to true if not provided")
    setOrganized: Optional[Boolean] = None
    skipMultipleMatchTag: Optional[String] = Field(None, description="tag to tag skipped multiple matches with")
    skipMultipleMatches: Optional[Boolean] = Field(None, description="defaults to true if not provided")
    skipSingleNamePerformerTag: Optional[String] = Field(
        None, description="tag to tag skipped single name performers with"
    )
    skipSingleNamePerformers: Optional[Boolean] = Field(None, description="defaults to true if not provided")
    typename__: Optional[Literal["IdentifyMetadataOptionsInput"]] = Field(
        "IdentifyMetadataOptionsInput", alias="__typename"
    )


class IdentifySourceInput(BaseModel):
    options: Optional[IdentifyMetadataOptionsInput] = Field(
        None, description="Options defined for a source override the defaults"
    )
    source: ScraperSourceInput
    typename__: Optional[Literal["IdentifySourceInput"]] = Field("IdentifySourceInput", alias="__typename")


class ImageDestroyInput(BaseModel):
    delete_file: Optional[Boolean] = None
    delete_generated: Optional[Boolean] = None
    id: ID
    typename__: Optional[Literal["ImageDestroyInput"]] = Field("ImageDestroyInput", alias="__typename")


class ImageFilterType(BaseModel):
    AND: Optional[ImageFilterType] = None
    NOT: Optional[ImageFilterType] = None
    OR: Optional[ImageFilterType] = None
    checksum: Optional[StringCriterionInput] = Field(None, description="Filter by file checksum")
    code: Optional[StringCriterionInput] = Field(None, description="Filter by studio code")
    created_at: Optional[TimestampCriterionInput] = Field(None, description="Filter by creation time")
    date: Optional[DateCriterionInput] = Field(None, description="Filter by date")
    details: Optional[StringCriterionInput] = None
    file_count: Optional[IntCriterionInput] = Field(None, description="Filter by file count")
    galleries: Optional[MultiCriterionInput] = Field(
        None, description="Filter to only include images with these galleries"
    )
    galleries_filter: Optional[GalleryFilterType] = Field(
        None, description="Filter by related galleries that meet this criteria"
    )
    id: Optional[IntCriterionInput] = Field(None, description=" Filter by image id")
    is_missing: Optional[String] = Field(None, description="Filter to only include images missing this property")
    o_counter: Optional[IntCriterionInput] = Field(None, description="Filter by o-counter")
    organized: Optional[Boolean] = Field(None, description="Filter by organized")
    orientation: Optional[OrientationCriterionInput] = Field(None, description="Filter by orientation")
    path: Optional[StringCriterionInput] = Field(None, description="Filter by path")
    performer_age: Optional[IntCriterionInput] = Field(
        None, description="Filter images by performer age at time of image"
    )
    performer_count: Optional[IntCriterionInput] = Field(None, description="Filter by performer count")
    performer_favorite: Optional[Boolean] = Field(
        None, description="Filter images that have performers that have been favorited"
    )
    performer_tags: Optional[HierarchicalMultiCriterionInput] = Field(
        None, description="Filter to only include images with performers with these tags"
    )
    performers: Optional[MultiCriterionInput] = Field(
        None, description="Filter to only include images with these performers"
    )
    performers_filter: Optional[PerformerFilterType] = Field(
        None, description="Filter by related performers that meet this criteria"
    )
    photographer: Optional[StringCriterionInput] = Field(None, description="Filter by photographer")
    rating100: Optional[IntCriterionInput] = None
    resolution: Optional[ResolutionCriterionInput] = Field(None, description="Filter by resolution")
    studios: Optional[HierarchicalMultiCriterionInput] = Field(
        None, description="Filter to only include images with this studio"
    )
    studios_filter: Optional[StudioFilterType] = Field(
        None, description="Filter by related studios that meet this criteria"
    )
    tag_count: Optional[IntCriterionInput] = Field(None, description="Filter by tag count")
    tags: Optional[HierarchicalMultiCriterionInput] = Field(
        None, description="Filter to only include images with these tags"
    )
    tags_filter: Optional[TagFilterType] = Field(None, description="Filter by related tags that meet this criteria")
    title: Optional[StringCriterionInput] = None
    updated_at: Optional[TimestampCriterionInput] = Field(None, description="Filter by last update time")
    url: Optional[StringCriterionInput] = Field(None, description="Filter by url")
    typename__: Optional[Literal["ImageFilterType"]] = Field("ImageFilterType", alias="__typename")


class ImageUpdateInput(BaseModel):
    clientMutationId: Optional[String] = None
    code: Optional[String] = None
    date: Optional[String] = None
    details: Optional[String] = None
    gallery_ids: Optional[List[ID]] = None
    id: ID
    organized: Optional[Boolean] = None
    performer_ids: Optional[List[ID]] = None
    photographer: Optional[String] = None
    primary_file_id: Optional[ID] = None
    rating100: Optional[Int] = None
    studio_id: Optional[ID] = None
    tag_ids: Optional[List[ID]] = None
    title: Optional[String] = None
    url: Optional[String] = None
    urls: Optional[List[String]] = None
    typename__: Optional[Literal["ImageUpdateInput"]] = Field("ImageUpdateInput", alias="__typename")


class ImagesDestroyInput(BaseModel):
    delete_file: Optional[Boolean] = None
    delete_generated: Optional[Boolean] = None
    ids: List[ID]
    typename__: Optional[Literal["ImagesDestroyInput"]] = Field("ImagesDestroyInput", alias="__typename")


class ImportObjectsInput(BaseModel):
    duplicateBehaviour: ImportDuplicateEnum
    file: Upload
    missingRefBehaviour: ImportMissingRefEnum
    typename__: Optional[Literal["ImportObjectsInput"]] = Field("ImportObjectsInput", alias="__typename")


class IntCriterionInput(BaseModel):
    modifier: CriterionModifier
    value: Int
    value2: Optional[Int] = None
    typename__: Optional[Literal["IntCriterionInput"]] = Field("IntCriterionInput", alias="__typename")


class MigrateBlobsInput(BaseModel):
    deleteOld: Optional[Boolean] = None
    typename__: Optional[Literal["MigrateBlobsInput"]] = Field("MigrateBlobsInput", alias="__typename")


class MigrateInput(BaseModel):
    backupPath: String
    typename__: Optional[Literal["MigrateInput"]] = Field("MigrateInput", alias="__typename")


class MigrateSceneScreenshotsInput(BaseModel):
    deleteFiles: Optional[Boolean] = None
    overwriteExisting: Optional[Boolean] = None
    typename__: Optional[Literal["MigrateSceneScreenshotsInput"]] = Field(
        "MigrateSceneScreenshotsInput", alias="__typename"
    )


class MoveFilesInput(BaseModel):
    destination_basename: Optional[String] = Field(
        None, description="valid only for single file id. If empty, existing basename is used"
    )
    destination_folder: Optional[String] = Field(None, description="valid for single or multiple file ids")
    destination_folder_id: Optional[ID] = Field(None, description="valid for single or multiple file ids")
    ids: List[ID]
    typename__: Optional[Literal["MoveFilesInput"]] = Field("MoveFilesInput", alias="__typename")


class MovieCreateInput(BaseModel):
    aliases: Optional[String] = None
    back_image: Optional[String] = Field(None, description="This should be a URL or a base64 encoded data URL")
    date: Optional[String] = None
    director: Optional[String] = None
    duration: Optional[Int] = Field(None, description="Duration in seconds")
    front_image: Optional[String] = Field(None, description="This should be a URL or a base64 encoded data URL")
    name: String
    rating100: Optional[Int] = None
    studio_id: Optional[ID] = None
    synopsis: Optional[String] = None
    tag_ids: Optional[List[ID]] = None
    url: Optional[String] = None
    urls: Optional[List[String]] = None
    typename__: Optional[Literal["MovieCreateInput"]] = Field("MovieCreateInput", alias="__typename")


class MovieDestroyInput(BaseModel):
    id: ID
    typename__: Optional[Literal["MovieDestroyInput"]] = Field("MovieDestroyInput", alias="__typename")


class MovieFilterType(BaseModel):
    AND: Optional[MovieFilterType] = None
    NOT: Optional[MovieFilterType] = None
    OR: Optional[MovieFilterType] = None
    created_at: Optional[TimestampCriterionInput] = Field(None, description="Filter by creation time")
    date: Optional[DateCriterionInput] = Field(None, description="Filter by date")
    director: Optional[StringCriterionInput] = None
    duration: Optional[IntCriterionInput] = Field(None, description="Filter by duration (in seconds)")
    is_missing: Optional[String] = Field(None, description="Filter to only include movies missing this property")
    name: Optional[StringCriterionInput] = None
    performers: Optional[MultiCriterionInput] = Field(
        None, description="Filter to only include movies where performer appears in a scene"
    )
    rating100: Optional[IntCriterionInput] = None
    scenes_filter: Optional[SceneFilterType] = Field(
        None, description="Filter by related scenes that meet this criteria"
    )
    studios: Optional[HierarchicalMultiCriterionInput] = Field(
        None, description="Filter to only include movies with this studio"
    )
    studios_filter: Optional[StudioFilterType] = Field(
        None, description="Filter by related studios that meet this criteria"
    )
    synopsis: Optional[StringCriterionInput] = None
    tag_count: Optional[IntCriterionInput] = Field(None, description="Filter by tag count")
    tags: Optional[HierarchicalMultiCriterionInput] = Field(
        None, description="Filter to only include movies with these tags"
    )
    updated_at: Optional[TimestampCriterionInput] = Field(None, description="Filter by last update time")
    url: Optional[StringCriterionInput] = Field(None, description="Filter by url")
    typename__: Optional[Literal["MovieFilterType"]] = Field("MovieFilterType", alias="__typename")


class MovieUpdateInput(BaseModel):
    aliases: Optional[String] = None
    back_image: Optional[String] = Field(None, description="This should be a URL or a base64 encoded data URL")
    date: Optional[String] = None
    director: Optional[String] = None
    duration: Optional[Int] = None
    front_image: Optional[String] = Field(None, description="This should be a URL or a base64 encoded data URL")
    id: ID
    name: Optional[String] = None
    rating100: Optional[Int] = None
    studio_id: Optional[ID] = None
    synopsis: Optional[String] = None
    tag_ids: Optional[List[ID]] = None
    url: Optional[String] = None
    urls: Optional[List[String]] = None
    typename__: Optional[Literal["MovieUpdateInput"]] = Field("MovieUpdateInput", alias="__typename")


class MultiCriterionInput(BaseModel):
    excludes: Optional[List[ID]] = None
    modifier: CriterionModifier
    value: Optional[List[ID]] = None
    typename__: Optional[Literal["MultiCriterionInput"]] = Field("MultiCriterionInput", alias="__typename")


class OrientationCriterionInput(BaseModel):
    value: List[OrientationEnum]
    typename__: Optional[Literal["OrientationCriterionInput"]] = Field("OrientationCriterionInput", alias="__typename")


class PHashDuplicationCriterionInput(BaseModel):
    distance: Optional[Int] = Field(None, description="Currently unimplemented")
    duplicated: Optional[Boolean] = None
    typename__: Optional[Literal["PHashDuplicationCriterionInput"]] = Field(
        "PHashDuplicationCriterionInput", alias="__typename"
    )


class PackageSourceInput(BaseModel):
    local_path: Optional[String] = None
    name: Optional[String] = None
    url: String
    typename__: Optional[Literal["PackageSourceInput"]] = Field("PackageSourceInput", alias="__typename")


class PackageSpecInput(BaseModel):
    id: String
    sourceURL: String
    typename__: Optional[Literal["PackageSpecInput"]] = Field("PackageSpecInput", alias="__typename")


class PerformerCreateInput(BaseModel):
    alias_list: Optional[List[String]] = None
    birthdate: Optional[String] = None
    career_length: Optional[String] = None
    circumcised: Optional[CircumisedEnum] = None
    country: Optional[String] = None
    custom_fields: Optional[Map] = None
    death_date: Optional[String] = None
    details: Optional[String] = None
    disambiguation: Optional[String] = None
    ethnicity: Optional[String] = None
    eye_color: Optional[String] = None
    fake_tits: Optional[String] = None
    favorite: Optional[Boolean] = None
    gender: Optional[GenderEnum] = None
    hair_color: Optional[String] = None
    height_cm: Optional[Int] = None
    ignore_auto_tag: Optional[Boolean] = None
    image: Optional[String] = Field(None, description="This should be a URL or a base64 encoded data URL")
    instagram: Optional[String] = None
    measurements: Optional[String] = None
    name: String
    penis_length: Optional[Float] = None
    piercings: Optional[String] = None
    rating100: Optional[Int] = None
    stash_ids: Optional[List[StashIDInput]] = None
    tag_ids: Optional[List[ID]] = None
    tattoos: Optional[String] = None
    twitter: Optional[String] = None
    url: Optional[String] = None
    urls: Optional[List[String]] = None
    weight: Optional[Int] = None
    typename__: Optional[Literal["PerformerCreateInput"]] = Field("PerformerCreateInput", alias="__typename")


class PerformerDestroyInput(BaseModel):
    id: ID
    typename__: Optional[Literal["PerformerDestroyInput"]] = Field("PerformerDestroyInput", alias="__typename")


class PerformerFilterType(BaseModel):
    AND: Optional[PerformerFilterType] = None
    NOT: Optional[PerformerFilterType] = None
    OR: Optional[PerformerFilterType] = None
    age: Optional[IntCriterionInput] = Field(None, description="Filter by age")
    aliases: Optional[StringCriterionInput] = Field(None, description="Filter by aliases")
    birth_year: Optional[IntCriterionInput] = Field(None, description="Filter by birth year")
    birthdate: Optional[DateCriterionInput] = Field(None, description="Filter by birthdate")
    career_length: Optional[StringCriterionInput] = Field(None, description="Filter by career length")
    circumcised: Optional[CircumcisionCriterionInput] = Field(None, description="Filter by ciricumcision")
    country: Optional[StringCriterionInput] = Field(None, description="Filter by country")
    created_at: Optional[TimestampCriterionInput] = Field(None, description="Filter by creation time")
    custom_fields: Optional[List[CustomFieldCriterionInput]] = None
    death_date: Optional[DateCriterionInput] = Field(None, description="Filter by death date")
    death_year: Optional[IntCriterionInput] = Field(None, description="Filter by death year")
    details: Optional[StringCriterionInput] = None
    disambiguation: Optional[StringCriterionInput] = None
    ethnicity: Optional[StringCriterionInput] = Field(None, description="Filter by ethnicity")
    eye_color: Optional[StringCriterionInput] = Field(None, description="Filter by eye color")
    fake_tits: Optional[StringCriterionInput] = Field(None, description="Filter by fake tits value")
    filter_favorites: Optional[Boolean] = Field(None, description="Filter by favorite")
    galleries_filter: Optional[GalleryFilterType] = Field(
        None, description="Filter by related galleries that meet this criteria"
    )
    gallery_count: Optional[IntCriterionInput] = Field(None, description="Filter by gallery count")
    gender: Optional[GenderCriterionInput] = Field(None, description="Filter by gender")
    hair_color: Optional[StringCriterionInput] = Field(None, description="Filter by hair color")
    height_cm: Optional[IntCriterionInput] = Field(None, description="Filter by height in cm")
    ignore_auto_tag: Optional[Boolean] = Field(None, description="Filter by autotag ignore value")
    image_count: Optional[IntCriterionInput] = Field(None, description="Filter by image count")
    images_filter: Optional[ImageFilterType] = Field(
        None, description="Filter by related images that meet this criteria"
    )
    is_missing: Optional[String] = Field(None, description="Filter to only include performers missing this property")
    measurements: Optional[StringCriterionInput] = Field(None, description="Filter by measurements")
    name: Optional[StringCriterionInput] = None
    o_counter: Optional[IntCriterionInput] = Field(None, description="Filter by o count")
    penis_length: Optional[FloatCriterionInput] = Field(None, description="Filter by penis length value")
    performers: Optional[MultiCriterionInput] = Field(
        None, description="Filter by performers where performer appears with another performer in scene/image/gallery"
    )
    piercings: Optional[StringCriterionInput] = Field(None, description="Filter by piercings")
    play_count: Optional[IntCriterionInput] = Field(None, description="Filter by play count")
    rating100: Optional[IntCriterionInput] = None
    scene_count: Optional[IntCriterionInput] = Field(None, description="Filter by scene count")
    scenes_filter: Optional[SceneFilterType] = Field(
        None, description="Filter by related scenes that meet this criteria"
    )
    stash_id_endpoint: Optional[StashIDCriterionInput] = Field(None, description="Filter by StashID")
    studios: Optional[HierarchicalMultiCriterionInput] = Field(
        None, description="Filter by studios where performer appears in scene/image/gallery"
    )
    tag_count: Optional[IntCriterionInput] = Field(None, description="Filter by tag count")
    tags: Optional[HierarchicalMultiCriterionInput] = Field(
        None, description="Filter to only include performers with these tags"
    )
    tags_filter: Optional[TagFilterType] = Field(None, description="Filter by related tags that meet this criteria")
    tattoos: Optional[StringCriterionInput] = Field(None, description="Filter by tattoos")
    updated_at: Optional[TimestampCriterionInput] = Field(None, description="Filter by last update time")
    url: Optional[StringCriterionInput] = Field(None, description="Filter by url")
    weight: Optional[IntCriterionInput] = Field(None, description="Filter by weight")
    typename__: Optional[Literal["PerformerFilterType"]] = Field("PerformerFilterType", alias="__typename")


class PerformerUpdateInput(BaseModel):
    alias_list: Optional[List[String]] = None
    birthdate: Optional[String] = None
    career_length: Optional[String] = None
    circumcised: Optional[CircumisedEnum] = None
    country: Optional[String] = None
    custom_fields: Optional[CustomFieldsInput] = None
    death_date: Optional[String] = None
    details: Optional[String] = None
    disambiguation: Optional[String] = None
    ethnicity: Optional[String] = None
    eye_color: Optional[String] = None
    fake_tits: Optional[String] = None
    favorite: Optional[Boolean] = None
    gender: Optional[GenderEnum] = None
    hair_color: Optional[String] = None
    height_cm: Optional[Int] = None
    id: ID
    ignore_auto_tag: Optional[Boolean] = None
    image: Optional[String] = Field(None, description="This should be a URL or a base64 encoded data URL")
    instagram: Optional[String] = None
    measurements: Optional[String] = None
    name: Optional[String] = None
    penis_length: Optional[Float] = None
    piercings: Optional[String] = None
    rating100: Optional[Int] = None
    stash_ids: Optional[List[StashIDInput]] = None
    tag_ids: Optional[List[ID]] = None
    tattoos: Optional[String] = None
    twitter: Optional[String] = None
    url: Optional[String] = None
    urls: Optional[List[String]] = None
    weight: Optional[Int] = None
    typename__: Optional[Literal["PerformerUpdateInput"]] = Field("PerformerUpdateInput", alias="__typename")


class PhashDistanceCriterionInput(BaseModel):
    distance: Optional[Int] = None
    modifier: CriterionModifier
    value: String
    typename__: Optional[Literal["PhashDistanceCriterionInput"]] = Field(
        "PhashDistanceCriterionInput", alias="__typename"
    )


class PluginArgInput(BaseModel):
    key: String
    value: Optional[PluginValueInput] = None
    typename__: Optional[Literal["PluginArgInput"]] = Field("PluginArgInput", alias="__typename")


class PluginValueInput(BaseModel):
    a: Optional[List[PluginValueInput]] = None
    b: Optional[Boolean] = None
    f: Optional[Float] = None
    i: Optional[Int] = None
    o: Optional[List[PluginArgInput]] = None
    str: Optional[String] = None
    typename__: Optional[Literal["PluginValueInput"]] = Field("PluginValueInput", alias="__typename")


class RemoveTempDLNAIPInput(BaseModel):
    address: String
    typename__: Optional[Literal["RemoveTempDLNAIPInput"]] = Field("RemoveTempDLNAIPInput", alias="__typename")


class ReorderSubGroupsInput(BaseModel):
    group_id: ID = Field(..., description="ID of the group to reorder sub groups for")
    insert_after: Optional[Boolean] = Field(
        None,
        description="If true, the sub groups will be inserted after the insert_index, otherwise they will be inserted before",
    )
    insert_at_id: ID = Field(..., description="The sub-group ID at which to insert the sub groups")
    sub_group_ids: List[ID] = Field(
        ...,
        description="IDs of the sub groups to reorder. These must be a subset of the current sub groups.\nSub groups will be inserted in this order at the insert_index",
    )
    typename__: Optional[Literal["ReorderSubGroupsInput"]] = Field("ReorderSubGroupsInput", alias="__typename")


class ResolutionCriterionInput(BaseModel):
    modifier: CriterionModifier
    value: ResolutionEnum
    typename__: Optional[Literal["ResolutionCriterionInput"]] = Field("ResolutionCriterionInput", alias="__typename")


class SaveFilterInput(BaseModel):
    find_filter: Optional[FindFilterType] = None
    id: Optional[ID] = Field(None, description="provide ID to overwrite existing filter")
    mode: FilterMode
    name: String
    object_filter: Optional[Map] = None
    ui_options: Optional[Map] = None
    typename__: Optional[Literal["SaveFilterInput"]] = Field("SaveFilterInput", alias="__typename")


class ScanMetaDataFilterInput(BaseModel):
    """
    Filter options for meta data scannning
    """

    minModTime: Optional[Timestamp] = Field(
        None, description="If set, files with a modification time before this time point are ignored by the scan"
    )
    typename__: Optional[Literal["ScanMetaDataFilterInput"]] = Field("ScanMetaDataFilterInput", alias="__typename")


class ScanMetadataInput(BaseModel):
    filter: Optional[ScanMetaDataFilterInput] = Field(None, description="Filter options for the scan")
    paths: Optional[List[String]] = None
    rescan: Optional[Boolean] = Field(
        None, description="Forces a rescan on files even if modification time is unchanged"
    )
    scanGenerateClipPreviews: Optional[Boolean] = Field(None, description="Generate image clip previews during scan")
    scanGenerateCovers: Optional[Boolean] = Field(None, description="Generate covers during scan")
    scanGenerateImagePreviews: Optional[Boolean] = Field(None, description="Generate image previews during scan")
    scanGeneratePhashes: Optional[Boolean] = Field(None, description="Generate phashes during scan")
    scanGeneratePreviews: Optional[Boolean] = Field(None, description="Generate previews during scan")
    scanGenerateSprites: Optional[Boolean] = Field(None, description="Generate sprites during scan")
    scanGenerateThumbnails: Optional[Boolean] = Field(None, description="Generate image thumbnails during scan")
    typename__: Optional[Literal["ScanMetadataInput"]] = Field("ScanMetadataInput", alias="__typename")


class SceneCreateInput(BaseModel):
    code: Optional[String] = None
    cover_image: Optional[String] = Field(None, description="This should be a URL or a base64 encoded data URL")
    date: Optional[String] = None
    details: Optional[String] = None
    director: Optional[String] = None
    file_ids: Optional[List[ID]] = Field(
        None,
        description="The first id will be assigned as primary.\nFiles will be reassigned from existing scenes if applicable.\nFiles must not already be primary for another scene.",
    )
    gallery_ids: Optional[List[ID]] = None
    groups: Optional[List[SceneGroupInput]] = None
    movies: Optional[List[SceneMovieInput]] = None
    organized: Optional[Boolean] = None
    performer_ids: Optional[List[ID]] = None
    rating100: Optional[Int] = None
    stash_ids: Optional[List[StashIDInput]] = None
    studio_id: Optional[ID] = None
    tag_ids: Optional[List[ID]] = None
    title: Optional[String] = None
    url: Optional[String] = None
    urls: Optional[List[String]] = None
    typename__: Optional[Literal["SceneCreateInput"]] = Field("SceneCreateInput", alias="__typename")


class SceneDestroyInput(BaseModel):
    delete_file: Optional[Boolean] = None
    delete_generated: Optional[Boolean] = None
    id: ID
    typename__: Optional[Literal["SceneDestroyInput"]] = Field("SceneDestroyInput", alias="__typename")


class SceneFilterType(BaseModel):
    AND: Optional[SceneFilterType] = None
    NOT: Optional[SceneFilterType] = None
    OR: Optional[SceneFilterType] = None
    audio_codec: Optional[StringCriterionInput] = Field(None, description="Filter by audio codec")
    bitrate: Optional[IntCriterionInput] = Field(None, description="Filter by bit rate")
    captions: Optional[StringCriterionInput] = Field(None, description="Filter by captions")
    checksum: Optional[StringCriterionInput] = Field(None, description="Filter by file checksum")
    code: Optional[StringCriterionInput] = None
    created_at: Optional[TimestampCriterionInput] = Field(None, description="Filter by creation time")
    date: Optional[DateCriterionInput] = Field(None, description="Filter by date")
    details: Optional[StringCriterionInput] = None
    director: Optional[StringCriterionInput] = None
    duplicated: Optional[PHashDuplicationCriterionInput] = Field(
        None, description="Filter Scenes that have an exact phash match available"
    )
    duration: Optional[IntCriterionInput] = Field(None, description="Filter by duration (in seconds)")
    file_count: Optional[IntCriterionInput] = Field(None, description="Filter by file count")
    framerate: Optional[IntCriterionInput] = Field(None, description="Filter by frame rate")
    galleries: Optional[MultiCriterionInput] = Field(
        None, description="Filter to only include scenes with this gallery"
    )
    galleries_filter: Optional[GalleryFilterType] = Field(
        None, description="Filter by related galleries that meet this criteria"
    )
    groups: Optional[HierarchicalMultiCriterionInput] = Field(
        None, description="Filter to only include scenes with this group"
    )
    groups_filter: Optional[GroupFilterType] = Field(
        None, description="Filter by related groups that meet this criteria"
    )
    has_markers: Optional[String] = Field(
        None, description="Filter to only include scenes which have markers. `true` or `false`"
    )
    id: Optional[IntCriterionInput] = None
    interactive: Optional[Boolean] = Field(None, description="Filter by interactive")
    interactive_speed: Optional[IntCriterionInput] = Field(None, description="Filter by InteractiveSpeed")
    is_missing: Optional[String] = Field(None, description="Filter to only include scenes missing this property")
    last_played_at: Optional[TimestampCriterionInput] = Field(None, description="Filter by scene last played time")
    markers_filter: Optional[SceneMarkerFilterType] = Field(
        None, description="Filter by related markers that meet this criteria"
    )
    movies: Optional[MultiCriterionInput] = Field(None, description="Filter to only include scenes with this movie")
    movies_filter: Optional[MovieFilterType] = Field(
        None, description="Filter by related movies that meet this criteria"
    )
    o_counter: Optional[IntCriterionInput] = Field(None, description="Filter by o-counter")
    organized: Optional[Boolean] = Field(None, description="Filter by organized")
    orientation: Optional[OrientationCriterionInput] = Field(None, description="Filter by orientation")
    oshash: Optional[StringCriterionInput] = Field(None, description="Filter by file oshash")
    path: Optional[StringCriterionInput] = Field(None, description="Filter by path")
    performer_age: Optional[IntCriterionInput] = Field(
        None, description="Filter scenes by performer age at time of scene"
    )
    performer_count: Optional[IntCriterionInput] = Field(None, description="Filter by performer count")
    performer_favorite: Optional[Boolean] = Field(
        None, description="Filter scenes that have performers that have been favorited"
    )
    performer_tags: Optional[HierarchicalMultiCriterionInput] = Field(
        None, description="Filter to only include scenes with performers with these tags"
    )
    performers: Optional[MultiCriterionInput] = Field(
        None, description="Filter to only include scenes with these performers"
    )
    performers_filter: Optional[PerformerFilterType] = Field(
        None, description="Filter by related performers that meet this criteria"
    )
    phash: Optional[StringCriterionInput] = Field(None, description="Filter by file phash")
    phash_distance: Optional[PhashDistanceCriterionInput] = Field(None, description="Filter by file phash distance")
    play_count: Optional[IntCriterionInput] = Field(None, description="Filter by play count")
    play_duration: Optional[IntCriterionInput] = Field(None, description="Filter by play duration (in seconds)")
    rating100: Optional[IntCriterionInput] = None
    resolution: Optional[ResolutionCriterionInput] = Field(None, description="Filter by resolution")
    resume_time: Optional[IntCriterionInput] = Field(None, description="Filter by resume time")
    stash_id_endpoint: Optional[StashIDCriterionInput] = Field(None, description="Filter by StashID")
    studios: Optional[HierarchicalMultiCriterionInput] = Field(
        None, description="Filter to only include scenes with this studio"
    )
    studios_filter: Optional[StudioFilterType] = Field(
        None, description="Filter by related studios that meet this criteria"
    )
    tag_count: Optional[IntCriterionInput] = Field(None, description="Filter by tag count")
    tags: Optional[HierarchicalMultiCriterionInput] = Field(
        None, description="Filter to only include scenes with these tags"
    )
    tags_filter: Optional[TagFilterType] = Field(None, description="Filter by related tags that meet this criteria")
    title: Optional[StringCriterionInput] = None
    updated_at: Optional[TimestampCriterionInput] = Field(None, description="Filter by last update time")
    url: Optional[StringCriterionInput] = Field(None, description="Filter by url")
    video_codec: Optional[StringCriterionInput] = Field(None, description="Filter by video codec")
    typename__: Optional[Literal["SceneFilterType"]] = Field("SceneFilterType", alias="__typename")


class SceneGroupInput(BaseModel):
    group_id: ID
    scene_index: Optional[Int] = None
    typename__: Optional[Literal["SceneGroupInput"]] = Field("SceneGroupInput", alias="__typename")


class SceneHashInput(BaseModel):
    checksum: Optional[String] = None
    oshash: Optional[String] = None
    typename__: Optional[Literal["SceneHashInput"]] = Field("SceneHashInput", alias="__typename")


class SceneMarkerCreateInput(BaseModel):
    end_seconds: Optional[Float] = Field(
        None, description="The optional end time of the marker (in seconds). Supports decimals."
    )
    primary_tag_id: ID
    scene_id: ID
    seconds: Float = Field(..., description="The required start time of the marker (in seconds). Supports decimals.")
    tag_ids: Optional[List[ID]] = None
    title: String
    typename__: Optional[Literal["SceneMarkerCreateInput"]] = Field("SceneMarkerCreateInput", alias="__typename")


class SceneMarkerFilterType(BaseModel):
    created_at: Optional[TimestampCriterionInput] = Field(None, description="Filter by creation time")
    duration: Optional[FloatCriterionInput] = Field(None, description="Filter by duration (in seconds)")
    performers: Optional[MultiCriterionInput] = Field(
        None, description="Filter to only include scene markers with these performers"
    )
    scene_created_at: Optional[TimestampCriterionInput] = Field(None, description="Filter by cscene reation time")
    scene_date: Optional[DateCriterionInput] = Field(None, description="Filter by scene date")
    scene_filter: Optional[SceneFilterType] = Field(
        None, description="Filter by related scenes that meet this criteria"
    )
    scene_tags: Optional[HierarchicalMultiCriterionInput] = Field(
        None, description="Filter to only include scene markers attached to a scene with these tags"
    )
    scene_updated_at: Optional[TimestampCriterionInput] = Field(None, description="Filter by lscene ast update time")
    scenes: Optional[MultiCriterionInput] = Field(
        None, description="Filter to only include scene markers from these scenes"
    )
    tags: Optional[HierarchicalMultiCriterionInput] = Field(
        None, description="Filter to only include scene markers with these tags"
    )
    updated_at: Optional[TimestampCriterionInput] = Field(None, description="Filter by last update time")
    typename__: Optional[Literal["SceneMarkerFilterType"]] = Field("SceneMarkerFilterType", alias="__typename")


class SceneMarkerUpdateInput(BaseModel):
    end_seconds: Optional[Float] = Field(
        None, description="The end time of the marker (in seconds). Supports decimals."
    )
    id: ID
    primary_tag_id: Optional[ID] = None
    scene_id: Optional[ID] = None
    seconds: Optional[Float] = Field(None, description="The start time of the marker (in seconds). Supports decimals.")
    tag_ids: Optional[List[ID]] = None
    title: Optional[String] = None
    typename__: Optional[Literal["SceneMarkerUpdateInput"]] = Field("SceneMarkerUpdateInput", alias="__typename")


class SceneMergeInput(BaseModel):
    destination: ID
    o_history: Optional[Boolean] = None
    play_history: Optional[Boolean] = None
    source: List[ID] = Field(
        ...,
        description="If destination scene has no files, then the primary file of the\nfirst source scene will be assigned as primary",
    )
    values: Optional[SceneUpdateInput] = None
    typename__: Optional[Literal["SceneMergeInput"]] = Field("SceneMergeInput", alias="__typename")


class SceneMovieInput(BaseModel):
    movie_id: ID
    scene_index: Optional[Int] = None
    typename__: Optional[Literal["SceneMovieInput"]] = Field("SceneMovieInput", alias="__typename")


class SceneParserInput(BaseModel):
    capitalizeTitle: Optional[Boolean] = None
    ignoreOrganized: Optional[Boolean] = None
    ignoreWords: Optional[List[String]] = None
    whitespaceCharacters: Optional[String] = None
    typename__: Optional[Literal["SceneParserInput"]] = Field("SceneParserInput", alias="__typename")


class SceneUpdateInput(BaseModel):
    clientMutationId: Optional[String] = None
    code: Optional[String] = None
    cover_image: Optional[String] = Field(None, description="This should be a URL or a base64 encoded data URL")
    date: Optional[String] = None
    details: Optional[String] = None
    director: Optional[String] = None
    gallery_ids: Optional[List[ID]] = None
    groups: Optional[List[SceneGroupInput]] = None
    id: ID
    movies: Optional[List[SceneMovieInput]] = None
    o_counter: Optional[Int] = None
    organized: Optional[Boolean] = None
    performer_ids: Optional[List[ID]] = None
    play_count: Optional[Int] = Field(None, description="The number ot times a scene has been played")
    play_duration: Optional[Float] = Field(None, description="The total time a scene has spent playing")
    primary_file_id: Optional[ID] = None
    rating100: Optional[Int] = None
    resume_time: Optional[Float] = Field(None, description="The time index a scene was left at")
    stash_ids: Optional[List[StashIDInput]] = None
    studio_id: Optional[ID] = None
    tag_ids: Optional[List[ID]] = None
    title: Optional[String] = None
    url: Optional[String] = None
    urls: Optional[List[String]] = None
    typename__: Optional[Literal["SceneUpdateInput"]] = Field("SceneUpdateInput", alias="__typename")


class ScenesDestroyInput(BaseModel):
    delete_file: Optional[Boolean] = None
    delete_generated: Optional[Boolean] = None
    ids: List[ID]
    typename__: Optional[Literal["ScenesDestroyInput"]] = Field("ScenesDestroyInput", alias="__typename")


class ScrapeMultiPerformersInput(BaseModel):
    performer_ids: Optional[List[ID]] = Field(None, description="Instructs to query by scene fingerprints")
    typename__: Optional[Literal["ScrapeMultiPerformersInput"]] = Field(
        "ScrapeMultiPerformersInput", alias="__typename"
    )


class ScrapeMultiScenesInput(BaseModel):
    scene_ids: Optional[List[ID]] = Field(None, description="Instructs to query by scene fingerprints")
    typename__: Optional[Literal["ScrapeMultiScenesInput"]] = Field("ScrapeMultiScenesInput", alias="__typename")


class ScrapeSingleGalleryInput(BaseModel):
    gallery_id: Optional[ID] = Field(None, description="Instructs to query by gallery id")
    gallery_input: Optional[ScrapedGalleryInput] = Field(None, description="Instructs to query by gallery fragment")
    query: Optional[String] = Field(None, description="Instructs to query by string")
    typename__: Optional[Literal["ScrapeSingleGalleryInput"]] = Field("ScrapeSingleGalleryInput", alias="__typename")


class ScrapeSingleGroupInput(BaseModel):
    group_id: Optional[ID] = Field(None, description="Instructs to query by group id")
    group_input: Optional[ScrapedGroupInput] = Field(None, description="Instructs to query by group fragment")
    query: Optional[String] = Field(None, description="Instructs to query by string")
    typename__: Optional[Literal["ScrapeSingleGroupInput"]] = Field("ScrapeSingleGroupInput", alias="__typename")


class ScrapeSingleImageInput(BaseModel):
    image_id: Optional[ID] = Field(None, description="Instructs to query by image id")
    image_input: Optional[ScrapedImageInput] = Field(None, description="Instructs to query by image fragment")
    query: Optional[String] = Field(None, description="Instructs to query by string")
    typename__: Optional[Literal["ScrapeSingleImageInput"]] = Field("ScrapeSingleImageInput", alias="__typename")


class ScrapeSingleMovieInput(BaseModel):
    movie_id: Optional[ID] = Field(None, description="Instructs to query by movie id")
    movie_input: Optional[ScrapedMovieInput] = Field(None, description="Instructs to query by movie fragment")
    query: Optional[String] = Field(None, description="Instructs to query by string")
    typename__: Optional[Literal["ScrapeSingleMovieInput"]] = Field("ScrapeSingleMovieInput", alias="__typename")


class ScrapeSinglePerformerInput(BaseModel):
    performer_id: Optional[ID] = Field(None, description="Instructs to query by performer id")
    performer_input: Optional[ScrapedPerformerInput] = Field(
        None, description="Instructs to query by performer fragment"
    )
    query: Optional[String] = Field(None, description="Instructs to query by string")
    typename__: Optional[Literal["ScrapeSinglePerformerInput"]] = Field(
        "ScrapeSinglePerformerInput", alias="__typename"
    )


class ScrapeSingleSceneInput(BaseModel):
    query: Optional[String] = Field(None, description="Instructs to query by string")
    scene_id: Optional[ID] = Field(None, description="Instructs to query by scene fingerprints")
    scene_input: Optional[ScrapedSceneInput] = Field(None, description="Instructs to query by scene fragment")
    typename__: Optional[Literal["ScrapeSingleSceneInput"]] = Field("ScrapeSingleSceneInput", alias="__typename")


class ScrapeSingleStudioInput(BaseModel):
    query: Optional[String] = Field(None, description="Query can be either a name or a Stash ID")
    typename__: Optional[Literal["ScrapeSingleStudioInput"]] = Field("ScrapeSingleStudioInput", alias="__typename")


class ScrapedGalleryInput(BaseModel):
    code: Optional[String] = None
    date: Optional[String] = None
    details: Optional[String] = None
    photographer: Optional[String] = None
    title: Optional[String] = None
    url: Optional[String] = None
    urls: Optional[List[String]] = None
    typename__: Optional[Literal["ScrapedGalleryInput"]] = Field("ScrapedGalleryInput", alias="__typename")


class ScrapedGroupInput(BaseModel):
    aliases: Optional[String] = None
    date: Optional[String] = None
    director: Optional[String] = None
    duration: Optional[String] = None
    name: Optional[String] = None
    rating: Optional[String] = None
    synopsis: Optional[String] = None
    urls: Optional[List[String]] = None
    typename__: Optional[Literal["ScrapedGroupInput"]] = Field("ScrapedGroupInput", alias="__typename")


class ScrapedImageInput(BaseModel):
    code: Optional[String] = None
    date: Optional[String] = None
    details: Optional[String] = None
    title: Optional[String] = None
    urls: Optional[List[String]] = None
    typename__: Optional[Literal["ScrapedImageInput"]] = Field("ScrapedImageInput", alias="__typename")


class ScrapedMovieInput(BaseModel):
    aliases: Optional[String] = None
    date: Optional[String] = None
    director: Optional[String] = None
    duration: Optional[String] = None
    name: Optional[String] = None
    rating: Optional[String] = None
    synopsis: Optional[String] = None
    url: Optional[String] = None
    urls: Optional[List[String]] = None
    typename__: Optional[Literal["ScrapedMovieInput"]] = Field("ScrapedMovieInput", alias="__typename")


class ScrapedPerformerInput(BaseModel):
    aliases: Optional[String] = None
    birthdate: Optional[String] = None
    career_length: Optional[String] = None
    circumcised: Optional[String] = None
    country: Optional[String] = None
    death_date: Optional[String] = None
    details: Optional[String] = None
    disambiguation: Optional[String] = None
    ethnicity: Optional[String] = None
    eye_color: Optional[String] = None
    fake_tits: Optional[String] = None
    gender: Optional[String] = None
    hair_color: Optional[String] = None
    height: Optional[String] = None
    instagram: Optional[String] = None
    measurements: Optional[String] = None
    name: Optional[String] = None
    penis_length: Optional[String] = None
    piercings: Optional[String] = None
    remote_site_id: Optional[String] = None
    stored_id: Optional[ID] = Field(None, description="Set if performer matched")
    tattoos: Optional[String] = None
    twitter: Optional[String] = None
    url: Optional[String] = None
    urls: Optional[List[String]] = None
    weight: Optional[String] = None
    typename__: Optional[Literal["ScrapedPerformerInput"]] = Field("ScrapedPerformerInput", alias="__typename")


class ScrapedSceneInput(BaseModel):
    code: Optional[String] = None
    date: Optional[String] = None
    details: Optional[String] = None
    director: Optional[String] = None
    remote_site_id: Optional[String] = None
    title: Optional[String] = None
    url: Optional[String] = None
    urls: Optional[List[String]] = None
    typename__: Optional[Literal["ScrapedSceneInput"]] = Field("ScrapedSceneInput", alias="__typename")


class ScraperSourceInput(BaseModel):
    scraper_id: Optional[ID] = Field(
        None, description="Scraper ID to scrape with. Should be unset if stash_box_endpoint/stash_box_index is set"
    )
    stash_box_endpoint: Optional[String] = Field(None, description="Stash-box endpoint")
    stash_box_index: Optional[Int] = Field(
        None, description="Index of the configured stash-box instance to use. Should be unset if scraper_id is set"
    )
    typename__: Optional[Literal["ScraperSourceInput"]] = Field("ScraperSourceInput", alias="__typename")


class SetDefaultFilterInput(BaseModel):
    find_filter: Optional[FindFilterType] = Field(None, description="null to clear")
    mode: FilterMode
    object_filter: Optional[Map] = None
    ui_options: Optional[Map] = None
    typename__: Optional[Literal["SetDefaultFilterInput"]] = Field("SetDefaultFilterInput", alias="__typename")


class SetFingerprintsInput(BaseModel):
    type: String
    value: Optional[String] = Field(None, description="an null value will remove the fingerprint")
    typename__: Optional[Literal["SetFingerprintsInput"]] = Field("SetFingerprintsInput", alias="__typename")


class SetupInput(BaseModel):
    blobsLocation: String = Field(
        ..., description="Empty to indicate default - only applicable if storeBlobsInDatabase is false"
    )
    cacheLocation: String = Field(..., description="Empty to indicate default")
    configLocation: String = Field(..., description="Empty to indicate $HOME/.stash/config.yml default")
    databaseFile: String = Field(..., description="Empty to indicate default")
    generatedLocation: String = Field(..., description="Empty to indicate default")
    stashes: List[StashConfigInput]
    storeBlobsInDatabase: Boolean
    typename__: Optional[Literal["SetupInput"]] = Field("SetupInput", alias="__typename")


class StashBoxBatchTagInput(BaseModel):
    """
    If neither ids nor names are set, tag all items
    """

    createParent: Boolean = Field(
        ..., description="If batch adding studios, should their parent studios also be created?"
    )
    endpoint: Optional[Int] = Field(None, description="Stash endpoint to use for the tagging")
    exclude_fields: Optional[List[String]] = Field(None, description="Fields to exclude when executing the tagging")
    ids: Optional[List[ID]] = Field(None, description="If set, only tag these ids")
    names: Optional[List[String]] = Field(None, description="If set, only tag these names")
    performer_ids: Optional[List[ID]] = Field(None, description="If set, only tag these performer ids")
    performer_names: Optional[List[String]] = Field(None, description="If set, only tag these performer names")
    refresh: Boolean = Field(
        ...,
        description="Refresh items already tagged by StashBox if true. Only tag items with no StashBox tagging if false",
    )
    stash_box_endpoint: Optional[String] = Field(None, description="Endpoint of the stash-box instance to use")
    typename__: Optional[Literal["StashBoxBatchTagInput"]] = Field("StashBoxBatchTagInput", alias="__typename")


class StashBoxDraftSubmissionInput(BaseModel):
    id: String
    stash_box_endpoint: Optional[String] = None
    stash_box_index: Optional[Int] = None
    typename__: Optional[Literal["StashBoxDraftSubmissionInput"]] = Field(
        "StashBoxDraftSubmissionInput", alias="__typename"
    )


class StashBoxFingerprintSubmissionInput(BaseModel):
    scene_ids: List[String]
    stash_box_endpoint: Optional[String] = None
    stash_box_index: Optional[Int] = None
    typename__: Optional[Literal["StashBoxFingerprintSubmissionInput"]] = Field(
        "StashBoxFingerprintSubmissionInput", alias="__typename"
    )


class StashBoxInput(BaseModel):
    api_key: String
    endpoint: String
    name: String
    typename__: Optional[Literal["StashBoxInput"]] = Field("StashBoxInput", alias="__typename")


class StashBoxPerformerQueryInput(BaseModel):
    performer_ids: Optional[List[ID]] = Field(None, description="Instructs query by scene fingerprints")
    q: Optional[String] = Field(None, description="Query by query string")
    stash_box_endpoint: Optional[String] = Field(None, description="Endpoint of the stash-box instance to use")
    stash_box_index: Optional[Int] = Field(None, description="Index of the configured stash-box instance to use")
    typename__: Optional[Literal["StashBoxPerformerQueryInput"]] = Field(
        "StashBoxPerformerQueryInput", alias="__typename"
    )


class StashBoxSceneQueryInput(BaseModel):
    q: Optional[String] = Field(None, description="Query by query string")
    scene_ids: Optional[List[ID]] = Field(None, description="Instructs query by scene fingerprints")
    stash_box_endpoint: Optional[String] = Field(None, description="Endpoint of the stash-box instance to use")
    stash_box_index: Optional[Int] = Field(None, description="Index of the configured stash-box instance to use")
    typename__: Optional[Literal["StashBoxSceneQueryInput"]] = Field("StashBoxSceneQueryInput", alias="__typename")


class StashConfigInput(BaseModel):
    """
    Stash configuration details
    """

    excludeImage: Boolean
    excludeVideo: Boolean
    path: String
    typename__: Optional[Literal["StashConfigInput"]] = Field("StashConfigInput", alias="__typename")


class StashIDCriterionInput(BaseModel):
    endpoint: Optional[String] = Field(
        None,
        description="If present, this value is treated as a predicate.\nThat is, it will filter based on stash_ids with the matching endpoint",
    )
    modifier: CriterionModifier
    stash_id: Optional[String] = None
    typename__: Optional[Literal["StashIDCriterionInput"]] = Field("StashIDCriterionInput", alias="__typename")


class StashIDInput(BaseModel):
    endpoint: String
    stash_id: String
    updated_at: Optional[Time] = None
    typename__: Optional[Literal["StashIDInput"]] = Field("StashIDInput", alias="__typename")


class StringCriterionInput(BaseModel):
    modifier: CriterionModifier
    value: String
    typename__: Optional[Literal["StringCriterionInput"]] = Field("StringCriterionInput", alias="__typename")


class StudioCreateInput(BaseModel):
    aliases: Optional[List[String]] = None
    details: Optional[String] = None
    favorite: Optional[Boolean] = None
    ignore_auto_tag: Optional[Boolean] = None
    image: Optional[String] = Field(None, description="This should be a URL or a base64 encoded data URL")
    name: String
    parent_id: Optional[ID] = None
    rating100: Optional[Int] = None
    stash_ids: Optional[List[StashIDInput]] = None
    tag_ids: Optional[List[ID]] = None
    url: Optional[String] = None
    typename__: Optional[Literal["StudioCreateInput"]] = Field("StudioCreateInput", alias="__typename")


class StudioDestroyInput(BaseModel):
    id: ID
    typename__: Optional[Literal["StudioDestroyInput"]] = Field("StudioDestroyInput", alias="__typename")


class StudioFilterType(BaseModel):
    AND: Optional[StudioFilterType] = None
    NOT: Optional[StudioFilterType] = None
    OR: Optional[StudioFilterType] = None
    aliases: Optional[StringCriterionInput] = Field(None, description="Filter by studio aliases")
    child_count: Optional[IntCriterionInput] = Field(None, description="Filter by subsidiary studio count")
    created_at: Optional[TimestampCriterionInput] = Field(None, description="Filter by creation time")
    details: Optional[StringCriterionInput] = None
    favorite: Optional[Boolean] = Field(None, description="Filter by favorite")
    galleries_filter: Optional[GalleryFilterType] = Field(
        None, description="Filter by related galleries that meet this criteria"
    )
    gallery_count: Optional[IntCriterionInput] = Field(None, description="Filter by gallery count")
    ignore_auto_tag: Optional[Boolean] = Field(None, description="Filter by autotag ignore value")
    image_count: Optional[IntCriterionInput] = Field(None, description="Filter by image count")
    images_filter: Optional[ImageFilterType] = Field(
        None, description="Filter by related images that meet this criteria"
    )
    is_missing: Optional[String] = Field(None, description="Filter to only include studios missing this property")
    name: Optional[StringCriterionInput] = None
    parents: Optional[MultiCriterionInput] = Field(
        None, description="Filter to only include studios with this parent studio"
    )
    rating100: Optional[IntCriterionInput] = None
    scene_count: Optional[IntCriterionInput] = Field(None, description="Filter by scene count")
    scenes_filter: Optional[SceneFilterType] = Field(
        None, description="Filter by related scenes that meet this criteria"
    )
    stash_id_endpoint: Optional[StashIDCriterionInput] = Field(None, description="Filter by StashID")
    tag_count: Optional[IntCriterionInput] = Field(None, description="Filter by tag count")
    tags: Optional[HierarchicalMultiCriterionInput] = Field(
        None, description="Filter to only include studios with these tags"
    )
    updated_at: Optional[TimestampCriterionInput] = Field(None, description="Filter by last update time")
    url: Optional[StringCriterionInput] = Field(None, description="Filter by url")
    typename__: Optional[Literal["StudioFilterType"]] = Field("StudioFilterType", alias="__typename")


class StudioUpdateInput(BaseModel):
    aliases: Optional[List[String]] = None
    details: Optional[String] = None
    favorite: Optional[Boolean] = None
    id: ID
    ignore_auto_tag: Optional[Boolean] = None
    image: Optional[String] = Field(None, description="This should be a URL or a base64 encoded data URL")
    name: Optional[String] = None
    parent_id: Optional[ID] = None
    rating100: Optional[Int] = None
    stash_ids: Optional[List[StashIDInput]] = None
    tag_ids: Optional[List[ID]] = None
    url: Optional[String] = None
    typename__: Optional[Literal["StudioUpdateInput"]] = Field("StudioUpdateInput", alias="__typename")


class TagCreateInput(BaseModel):
    aliases: Optional[List[String]] = None
    child_ids: Optional[List[ID]] = None
    description: Optional[String] = None
    favorite: Optional[Boolean] = None
    ignore_auto_tag: Optional[Boolean] = None
    image: Optional[String] = Field(None, description="This should be a URL or a base64 encoded data URL")
    name: String
    parent_ids: Optional[List[ID]] = None
    sort_name: Optional[String] = Field(
        None, description="Value that does not appear in the UI but overrides name for sorting"
    )
    typename__: Optional[Literal["TagCreateInput"]] = Field("TagCreateInput", alias="__typename")


class TagDestroyInput(BaseModel):
    id: ID
    typename__: Optional[Literal["TagDestroyInput"]] = Field("TagDestroyInput", alias="__typename")


class TagFilterType(BaseModel):
    AND: Optional[TagFilterType] = None
    NOT: Optional[TagFilterType] = None
    OR: Optional[TagFilterType] = None
    aliases: Optional[StringCriterionInput] = Field(None, description="Filter by tag aliases")
    child_count: Optional[IntCriterionInput] = Field(None, description="Filter by number f child tags the tag has")
    children: Optional[HierarchicalMultiCriterionInput] = Field(None, description="Filter by child tags")
    created_at: Optional[TimestampCriterionInput] = Field(None, description="Filter by creation time")
    description: Optional[StringCriterionInput] = Field(None, description="Filter by tag description")
    favorite: Optional[Boolean] = Field(None, description="Filter by favorite")
    galleries_filter: Optional[GalleryFilterType] = Field(
        None, description="Filter by related galleries that meet this criteria"
    )
    gallery_count: Optional[IntCriterionInput] = Field(None, description="Filter by number of galleries with this tag")
    group_count: Optional[IntCriterionInput] = Field(None, description="Filter by number of group with this tag")
    ignore_auto_tag: Optional[Boolean] = Field(None, description="Filter by autotag ignore value")
    image_count: Optional[IntCriterionInput] = Field(None, description="Filter by number of images with this tag")
    images_filter: Optional[ImageFilterType] = Field(
        None, description="Filter by related images that meet this criteria"
    )
    is_missing: Optional[String] = Field(None, description="Filter to only include tags missing this property")
    marker_count: Optional[IntCriterionInput] = Field(None, description="Filter by number of markers with this tag")
    movie_count: Optional[IntCriterionInput] = Field(None, description="Filter by number of movies with this tag")
    name: Optional[StringCriterionInput] = Field(None, description="Filter by tag name")
    parent_count: Optional[IntCriterionInput] = Field(None, description="Filter by number of parent tags the tag has")
    parents: Optional[HierarchicalMultiCriterionInput] = Field(None, description="Filter by parent tags")
    performer_count: Optional[IntCriterionInput] = Field(
        None, description="Filter by number of performers with this tag"
    )
    scene_count: Optional[IntCriterionInput] = Field(None, description="Filter by number of scenes with this tag")
    scenes_filter: Optional[SceneFilterType] = Field(
        None, description="Filter by related scenes that meet this criteria"
    )
    sort_name: Optional[StringCriterionInput] = Field(None, description="Filter by tag sort_name")
    studio_count: Optional[IntCriterionInput] = Field(None, description="Filter by number of studios with this tag")
    updated_at: Optional[TimestampCriterionInput] = Field(None, description="Filter by last update time")
    typename__: Optional[Literal["TagFilterType"]] = Field("TagFilterType", alias="__typename")


class TagUpdateInput(BaseModel):
    aliases: Optional[List[String]] = None
    child_ids: Optional[List[ID]] = None
    description: Optional[String] = None
    favorite: Optional[Boolean] = None
    id: ID
    ignore_auto_tag: Optional[Boolean] = None
    image: Optional[String] = Field(None, description="This should be a URL or a base64 encoded data URL")
    name: Optional[String] = None
    parent_ids: Optional[List[ID]] = None
    sort_name: Optional[String] = Field(
        None, description="Value that does not appear in the UI but overrides name for sorting"
    )
    typename__: Optional[Literal["TagUpdateInput"]] = Field("TagUpdateInput", alias="__typename")


class TagsMergeInput(BaseModel):
    destination: ID
    source: List[ID]
    typename__: Optional[Literal["TagsMergeInput"]] = Field("TagsMergeInput", alias="__typename")


class TimestampCriterionInput(BaseModel):
    modifier: CriterionModifier
    value: String
    value2: Optional[String] = None
    typename__: Optional[Literal["TimestampCriterionInput"]] = Field("TimestampCriterionInput", alias="__typename")


# Scraped Content is the forming union over the different scrapers
ScrapedContent: TypeAlias = Union[
    "ScrapedGallery",
    "ScrapedGroup",
    "ScrapedImage",
    "ScrapedMovie",
    "ScrapedPerformer",
    "ScrapedScene",
    "ScrapedStudio",
    "ScrapedTag",
]


VisualFile: TypeAlias = Union[
    "ImageFile",
    "VideoFile",
]
